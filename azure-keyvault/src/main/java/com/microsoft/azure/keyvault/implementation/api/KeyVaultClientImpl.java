/**
 * Code generated by Microsoft (R) AutoRest Code Generator 0.17.0.0
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */

package com.microsoft.azure.keyvault.implementation.api;

import com.google.common.reflect.TypeToken;
import com.microsoft.azure.AzureClient;
import com.microsoft.azure.AzureServiceClient;
import com.microsoft.azure.AzureServiceResponseBuilder;
import com.microsoft.azure.ListOperationCallback;
import com.microsoft.azure.Page;
import com.microsoft.azure.PagedList;
import com.microsoft.azure.serializer.AzureJacksonMapperAdapter;
import com.microsoft.rest.credentials.ServiceClientCredentials;
import com.microsoft.rest.RestClient;
import com.microsoft.rest.serializer.CollectionFormat;
import com.microsoft.rest.ServiceCall;
import com.microsoft.rest.ServiceCallback;
import com.microsoft.rest.ServiceResponse;
import com.microsoft.rest.ServiceResponseCallback;
import com.microsoft.rest.Validator;
import java.io.IOException;
import java.util.List;
import java.util.Map;
import okhttp3.ResponseBody;
import retrofit2.Call;
import retrofit2.http.Body;
import retrofit2.http.GET;
import retrofit2.http.Header;
import retrofit2.http.Headers;
import retrofit2.http.HTTP;
import retrofit2.http.PATCH;
import retrofit2.http.Path;
import retrofit2.http.POST;
import retrofit2.http.PUT;
import retrofit2.http.Query;
import retrofit2.http.Url;
import retrofit2.Response;

/**
 * Initializes a new instance of the KeyVaultClientImpl class.
 */
public final class KeyVaultClientImpl extends AzureServiceClient {
    /** The Retrofit service to perform REST calls. */
    private KeyVaultClientService service;
    /** the {@link AzureClient} used for long running operations. */
    private AzureClient azureClient;

    /**
     * Gets the {@link AzureClient} used for long running operations.
     * @return the azure client;
     */
    public AzureClient getAzureClient() {
        return this.azureClient;
    }

    /** Client Api Version. */
    private String apiVersion;

    /**
     * Gets Client Api Version.
     *
     * @return the apiVersion value.
     */
    public String apiVersion() {
        return this.apiVersion;
    }

    /** Gets or sets the preferred language for the response. */
    private String acceptLanguage;

    /**
     * Gets Gets or sets the preferred language for the response.
     *
     * @return the acceptLanguage value.
     */
    public String acceptLanguage() {
        return this.acceptLanguage;
    }

    /**
     * Sets Gets or sets the preferred language for the response.
     *
     * @param acceptLanguage the acceptLanguage value.
     */
    public void setAcceptLanguage(String acceptLanguage) {
        this.acceptLanguage = acceptLanguage;
    }

    /** Gets or sets the retry timeout in seconds for Long Running Operations. Default value is 30. */
    private int longRunningOperationRetryTimeout;

    /**
     * Gets Gets or sets the retry timeout in seconds for Long Running Operations. Default value is 30.
     *
     * @return the longRunningOperationRetryTimeout value.
     */
    public int longRunningOperationRetryTimeout() {
        return this.longRunningOperationRetryTimeout;
    }

    /**
     * Sets Gets or sets the retry timeout in seconds for Long Running Operations. Default value is 30.
     *
     * @param longRunningOperationRetryTimeout the longRunningOperationRetryTimeout value.
     */
    public void setLongRunningOperationRetryTimeout(int longRunningOperationRetryTimeout) {
        this.longRunningOperationRetryTimeout = longRunningOperationRetryTimeout;
    }

    /** When set to true a unique x-ms-client-request-id value is generated and included in each request. Default is true. */
    private boolean generateClientRequestId;

    /**
     * Gets When set to true a unique x-ms-client-request-id value is generated and included in each request. Default is true.
     *
     * @return the generateClientRequestId value.
     */
    public boolean generateClientRequestId() {
        return this.generateClientRequestId;
    }

    /**
     * Sets When set to true a unique x-ms-client-request-id value is generated and included in each request. Default is true.
     *
     * @param generateClientRequestId the generateClientRequestId value.
     */
    public void setGenerateClientRequestId(boolean generateClientRequestId) {
        this.generateClientRequestId = generateClientRequestId;
    }

    /**
     * Initializes an instance of KeyVaultClient client.
     *
     * @param credentials the management credentials for Azure
     */
    public KeyVaultClientImpl(ServiceClientCredentials credentials) {
        this("{vaultBaseUrl}", credentials);
    }

    /**
     * Initializes an instance of KeyVaultClient client.
     *
     * @param baseUrl the base URL of the host
     * @param credentials the management credentials for Azure
     */
    private KeyVaultClientImpl(String baseUrl, ServiceClientCredentials credentials) {
        this(new RestClient.Builder(baseUrl)
                .withMapperAdapter(new AzureJacksonMapperAdapter())
                .withCredentials(credentials)
                .build());
    }

    /**
     * Initializes an instance of KeyVaultClient client.
     *
     * @param restClient the REST client to connect to Azure.
     */
    public KeyVaultClientImpl(RestClient restClient) {
        super(restClient);
        initialize();
    }

    protected void initialize() {
        this.apiVersion = "2015-06-01-preview2";
        this.acceptLanguage = "en-US";
        this.longRunningOperationRetryTimeout = 30;
        this.generateClientRequestId = true;
        this.azureClient = new AzureClient(this);
        initializeService();
    }

    /**
     * Gets the User-Agent header for the client.
     *
     * @return the user agent string.
     */
    @Override
    public String userAgent() {
        return String.format("Azure-SDK-For-Java/%s (%s)",
                getClass().getPackage().getImplementationVersion(),
                "KeyVaultClient, 2015-06-01-preview2");
    }

    private void initializeService() {
        service = restClient().retrofit().create(KeyVaultClientService.class);
    }

    /**
     * The interface defining all the services for KeyVaultClient to be
     * used by Retrofit to perform actually REST calls.
     */
    interface KeyVaultClientService {
        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("keys/{key-name}/create")
        Call<ResponseBody> createKey(@Path("key-name") String keyName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Body KeyCreateParameters parameters, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("keys/{key-name}")
        Call<ResponseBody> importKey(@Path("key-name") String keyName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Body KeyImportParameters parameters, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @HTTP(path = "keys/{key-name}", method = "DELETE", hasBody = true)
        Call<ResponseBody> deleteKey(@Path("key-name") String keyName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PATCH("keys/{key-name}/{key-version}")
        Call<ResponseBody> updateKey(@Path("key-name") String keyName, @Path("key-version") String keyVersion, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Body KeyUpdateParameters parameters, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("keys/{key-name}/{key-version}")
        Call<ResponseBody> getKey(@Path("key-name") String keyName, @Path("key-version") String keyVersion, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("keys/{key-name}/versions")
        Call<ResponseBody> getKeyVersions(@Path("key-name") String keyName, @Query("maxresults") Integer maxresults, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("keys")
        Call<ResponseBody> getKeys(@Query("maxresults") Integer maxresults, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("keys/{key-name}/backup")
        Call<ResponseBody> backupKey(@Path("key-name") String keyName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("keys/restore")
        Call<ResponseBody> restoreKey(@Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Body KeyRestoreParameters parameters, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("keys/{key-name}/{key-version}/encrypt")
        Call<ResponseBody> encrypt(@Path("key-name") String keyName, @Path("key-version") String keyVersion, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Body KeyOperationsParameters parameters, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("keys/{key-name}/{key-version}/decrypt")
        Call<ResponseBody> decrypt(@Path("key-name") String keyName, @Path("key-version") String keyVersion, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Body KeyOperationsParameters parameters, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("keys/{key-name}/{key-version}/sign")
        Call<ResponseBody> sign(@Path("key-name") String keyName, @Path("key-version") String keyVersion, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Body KeyOperationsParameters parameters, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("keys/{key-name}/{key-version}/verify")
        Call<ResponseBody> verify(@Path("key-name") String keyName, @Path("key-version") String keyVersion, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Body KeyVerifyParameters parameters, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("keys/{key-name}/{key-version}/wrapkey")
        Call<ResponseBody> wrapKey(@Path("key-name") String keyName, @Path("key-version") String keyVersion, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Body KeyOperationsParameters parameters, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("keys/{key-name}/{key-version}/unwrapkey")
        Call<ResponseBody> unwrapKey(@Path("key-name") String keyName, @Path("key-version") String keyVersion, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Body KeyOperationsParameters parameters, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("secrets/{secret-name}")
        Call<ResponseBody> setSecret(@Path("secret-name") String secretName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Body SecretSetParameters parameters, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @HTTP(path = "secrets/{secret-name}", method = "DELETE", hasBody = true)
        Call<ResponseBody> deleteSecret(@Path("secret-name") String secretName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PATCH("secrets/{secret-name}/{secret-version}")
        Call<ResponseBody> updateSecret(@Path("secret-name") String secretName, @Path("secret-version") String secretVersion, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Body SecretUpdateParameters parameters, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("secrets/{secret-name}/{secret-version}")
        Call<ResponseBody> getSecret(@Path("secret-name") String secretName, @Path("secret-version") String secretVersion, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("secrets")
        Call<ResponseBody> getSecrets(@Query("maxresults") Integer maxresults, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("secrets/{secret-name}/versions")
        Call<ResponseBody> getSecretVersions(@Path("secret-name") String secretName, @Query("maxresults") Integer maxresults, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("certificates")
        Call<ResponseBody> getCertificates(@Query("maxresults") Integer maxresults, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @HTTP(path = "certificates/{certificate-name}", method = "DELETE", hasBody = true)
        Call<ResponseBody> deleteCertificate(@Path("certificate-name") String certificateName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("certificates/contacts")
        Call<ResponseBody> setCertificateContacts(@Body ContactsInner contacts, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("certificates/contacts")
        Call<ResponseBody> getCertificateContacts(@Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @HTTP(path = "certificates/contacts", method = "DELETE", hasBody = true)
        Call<ResponseBody> deleteCertificateContacts(@Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("certificates/issuers")
        Call<ResponseBody> getCertificateIssuers(@Query("maxresults") Integer maxresults, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("certificates/issuers/{issuer-name}")
        Call<ResponseBody> setCertificateIssuer(@Path("issuer-name") String issuerName, @Body IssuerBundleInner issuer, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PATCH("certificates/issuers/{issuer-name}")
        Call<ResponseBody> updateCertificateIssuer(@Path("issuer-name") String issuerName, @Body IssuerBundleInner issuer, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("certificates/issuers/{issuer-name}")
        Call<ResponseBody> getCertificateIssuer(@Path("issuer-name") String issuerName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @HTTP(path = "certificates/issuers/{issuer-name}", method = "DELETE", hasBody = true)
        Call<ResponseBody> deleteCertificateIssuer(@Path("issuer-name") String issuerName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("certificates/{certificate-name}/create")
        Call<ResponseBody> createCertificate(@Path("certificate-name") String certificateName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Body CertificateCreateParameters parameters, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("certificates/{certificate-name}/import")
        Call<ResponseBody> importCertificate(@Path("certificate-name") String certificateName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Body CertificateImportParameters parameters, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("certificates/{certificate-name}/versions")
        Call<ResponseBody> getCertificateVersions(@Path("certificate-name") String certificateName, @Query("maxresults") Integer maxresults, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("certificates/{certificate-name}/policy")
        Call<ResponseBody> getCertificatePolicy(@Path("certificate-name") String certificateName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PATCH("certificates/{certificate-name}/policy")
        Call<ResponseBody> updateCertificatePolicy(@Path("certificate-name") String certificateName, @Body CertificatePolicyInner certificatePolicy, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PATCH("certificates/{certificate-name}/{certificate-version}")
        Call<ResponseBody> updateCertificate(@Path("certificate-name") String certificateName, @Path("certificate-version") String certificateVersion, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Body CertificateUpdateParameters parameters, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("certificates/{certificate-name}/{certificate-version}")
        Call<ResponseBody> getCertificate(@Path("certificate-name") String certificateName, @Path("certificate-version") String certificateVersion, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @PATCH("certificates/{certificate-name}/pending")
        Call<ResponseBody> updateCertificateOperation(@Path("certificate-name") String certificateName, @Body CertificateOperationInner certificateOperation, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("certificates/{certificate-name}/pending")
        Call<ResponseBody> getCertificateOperation(@Path("certificate-name") String certificateName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @HTTP(path = "certificates/{certificate-name}/pending", method = "DELETE", hasBody = true)
        Call<ResponseBody> deleteCertificateOperation(@Path("certificate-name") String certificateName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @POST("certificates/{certificate-name}/pending/merge")
        Call<ResponseBody> mergeCertificate(@Path("certificate-name") String certificateName, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Body CertificateMergeParameters parameters, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET
        Call<ResponseBody> getKeyVersionsNext(@Url String nextPageLink, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET
        Call<ResponseBody> getKeysNext(@Url String nextPageLink, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET
        Call<ResponseBody> getSecretsNext(@Url String nextPageLink, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET
        Call<ResponseBody> getSecretVersionsNext(@Url String nextPageLink, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET
        Call<ResponseBody> getCertificatesNext(@Url String nextPageLink, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET
        Call<ResponseBody> getCertificateIssuersNext(@Url String nextPageLink, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET
        Call<ResponseBody> getCertificateVersionsNext(@Url String nextPageLink, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

    }

    /**
     * Creates a new, named, key in the specified vault.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param keyName The name of the key
     * @param kty The type of key to create. For valid key types, see WebKeyTypes.
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the KeyBundleInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<KeyBundleInner> createKey(String vaultBaseUrl, String keyName, String kty) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (keyName == null) {
            throw new IllegalArgumentException("Parameter keyName is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        if (kty == null) {
            throw new IllegalArgumentException("Parameter kty is required and cannot be null.");
        }
        final Integer keySize = null;
        final String keyOpsConverted = null;
        final KeyAttributesInner keyAttributes = null;
        final Map<String, String> tags = null;
        KeyCreateParameters parameters = new KeyCreateParameters();
        parameters.setKty(kty);
        parameters.setKeySize(null);
        parameters.setKeyOps(null);
        parameters.setKeyAttributes(null);
        parameters.setTags(null);
        this.restClient().setBaseUrl("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.createKey(keyName, this.apiVersion(), this.acceptLanguage(), parameters, this.userAgent());
        return createKeyDelegate(call.execute());
    }

    /**
     * Creates a new, named, key in the specified vault.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param keyName The name of the key
     * @param kty The type of key to create. For valid key types, see WebKeyTypes.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if callback is null
     * @return the {@link Call} object
     */
    public ServiceCall createKeyAsync(String vaultBaseUrl, String keyName, String kty, final ServiceCallback<KeyBundleInner> serviceCallback) throws IllegalArgumentException {
        if (serviceCallback == null) {
            throw new IllegalArgumentException("ServiceCallback is required for async calls.");
        }
        if (vaultBaseUrl == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null."));
            return null;
        }
        if (keyName == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter keyName is required and cannot be null."));
            return null;
        }
        if (this.apiVersion() == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null."));
            return null;
        }
        if (kty == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter kty is required and cannot be null."));
            return null;
        }
        final Integer keySize = null;
        final String keyOpsConverted = null;
        final KeyAttributesInner keyAttributes = null;
        final Map<String, String> tags = null;
        KeyCreateParameters parameters = new KeyCreateParameters();
        parameters.setKty(kty);
        parameters.setKeySize(null);
        parameters.setKeyOps(null);
        parameters.setKeyAttributes(null);
        parameters.setTags(null);
        this.restClient().setBaseUrl("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.createKey(keyName, this.apiVersion(), this.acceptLanguage(), parameters, this.userAgent());
        final ServiceCall serviceCall = new ServiceCall(call);
        call.enqueue(new ServiceResponseCallback<KeyBundleInner>(serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    serviceCallback.success(createKeyDelegate(response));
                } catch (KeyVaultErrorException | IOException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    /**
     * Creates a new, named, key in the specified vault.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param keyName The name of the key
     * @param kty The type of key to create. For valid key types, see WebKeyTypes.
     * @param keySize Size of the key
     * @param keyOps the List&lt;String&gt; value
     * @param keyAttributes the KeyAttributesInner value
     * @param tags Application-specific metadata in the form of key-value pairs
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the KeyBundleInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<KeyBundleInner> createKey(String vaultBaseUrl, String keyName, String kty, Integer keySize, List<String> keyOps, KeyAttributesInner keyAttributes, Map<String, String> tags) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (keyName == null) {
            throw new IllegalArgumentException("Parameter keyName is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        if (kty == null) {
            throw new IllegalArgumentException("Parameter kty is required and cannot be null.");
        }
        Validator.validate(keyOps);
        Validator.validate(keyAttributes);
        Validator.validate(tags);
        KeyCreateParameters parameters = new KeyCreateParameters();
        parameters.setKty(kty);
        parameters.setKeySize(keySize);
        parameters.setKeyOps(keyOps);
        parameters.setKeyAttributes(keyAttributes);
        parameters.setTags(tags);
        this.restClient().setBaseUrl("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.createKey(keyName, this.apiVersion(), this.acceptLanguage(), parameters, this.userAgent());
        return createKeyDelegate(call.execute());
    }

    /**
     * Creates a new, named, key in the specified vault.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param keyName The name of the key
     * @param kty The type of key to create. For valid key types, see WebKeyTypes.
     * @param keySize Size of the key
     * @param keyOps the List&lt;String&gt; value
     * @param keyAttributes the KeyAttributesInner value
     * @param tags Application-specific metadata in the form of key-value pairs
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if callback is null
     * @return the {@link Call} object
     */
    public ServiceCall createKeyAsync(String vaultBaseUrl, String keyName, String kty, Integer keySize, List<String> keyOps, KeyAttributesInner keyAttributes, Map<String, String> tags, final ServiceCallback<KeyBundleInner> serviceCallback) throws IllegalArgumentException {
        if (serviceCallback == null) {
            throw new IllegalArgumentException("ServiceCallback is required for async calls.");
        }
        if (vaultBaseUrl == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null."));
            return null;
        }
        if (keyName == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter keyName is required and cannot be null."));
            return null;
        }
        if (this.apiVersion() == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null."));
            return null;
        }
        if (kty == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter kty is required and cannot be null."));
            return null;
        }
        Validator.validate(keyOps, serviceCallback);
        Validator.validate(keyAttributes, serviceCallback);
        Validator.validate(tags, serviceCallback);
        KeyCreateParameters parameters = new KeyCreateParameters();
        parameters.setKty(kty);
        parameters.setKeySize(keySize);
        parameters.setKeyOps(keyOps);
        parameters.setKeyAttributes(keyAttributes);
        parameters.setTags(tags);
        this.restClient().setBaseUrl("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.createKey(keyName, this.apiVersion(), this.acceptLanguage(), parameters, this.userAgent());
        final ServiceCall serviceCall = new ServiceCall(call);
        call.enqueue(new ServiceResponseCallback<KeyBundleInner>(serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    serviceCallback.success(createKeyDelegate(response));
                } catch (KeyVaultErrorException | IOException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<KeyBundleInner> createKeyDelegate(Response<ResponseBody> response) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<KeyBundleInner, KeyVaultErrorException>(this.restClient().mapperAdapter())
                .register(200, new TypeToken<KeyBundleInner>() { }.getType())
                .registerError(KeyVaultErrorException.class)
                .build(response);
    }

    /**
     * Imports a key into the specified vault.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param keyName The name of the key
     * @param key The Json web key
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the KeyBundleInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<KeyBundleInner> importKey(String vaultBaseUrl, String keyName, JsonWebKeyInner key) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (keyName == null) {
            throw new IllegalArgumentException("Parameter keyName is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        if (key == null) {
            throw new IllegalArgumentException("Parameter key is required and cannot be null.");
        }
        Validator.validate(key);
        final Boolean hsm = null;
        final KeyAttributesInner keyAttributes = null;
        final Map<String, String> tags = null;
        KeyImportParameters parameters = new KeyImportParameters();
        parameters.setHsm(null);
        parameters.setKey(key);
        parameters.setKeyAttributes(null);
        parameters.setTags(null);
        this.restClient().setBaseUrl("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.importKey(keyName, this.apiVersion(), this.acceptLanguage(), parameters, this.userAgent());
        return importKeyDelegate(call.execute());
    }

    /**
     * Imports a key into the specified vault.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param keyName The name of the key
     * @param key The Json web key
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if callback is null
     * @return the {@link Call} object
     */
    public ServiceCall importKeyAsync(String vaultBaseUrl, String keyName, JsonWebKeyInner key, final ServiceCallback<KeyBundleInner> serviceCallback) throws IllegalArgumentException {
        if (serviceCallback == null) {
            throw new IllegalArgumentException("ServiceCallback is required for async calls.");
        }
        if (vaultBaseUrl == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null."));
            return null;
        }
        if (keyName == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter keyName is required and cannot be null."));
            return null;
        }
        if (this.apiVersion() == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null."));
            return null;
        }
        if (key == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter key is required and cannot be null."));
            return null;
        }
        Validator.validate(key, serviceCallback);
        final Boolean hsm = null;
        final KeyAttributesInner keyAttributes = null;
        final Map<String, String> tags = null;
        KeyImportParameters parameters = new KeyImportParameters();
        parameters.setHsm(null);
        parameters.setKey(key);
        parameters.setKeyAttributes(null);
        parameters.setTags(null);
        this.restClient().setBaseUrl("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.importKey(keyName, this.apiVersion(), this.acceptLanguage(), parameters, this.userAgent());
        final ServiceCall serviceCall = new ServiceCall(call);
        call.enqueue(new ServiceResponseCallback<KeyBundleInner>(serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    serviceCallback.success(importKeyDelegate(response));
                } catch (KeyVaultErrorException | IOException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    /**
     * Imports a key into the specified vault.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param keyName The name of the key
     * @param key The Json web key
     * @param hsm Whether to import as a hardware key (HSM) or software key
     * @param keyAttributes The key management attributes
     * @param tags Application-specific metadata in the form of key-value pairs
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the KeyBundleInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<KeyBundleInner> importKey(String vaultBaseUrl, String keyName, JsonWebKeyInner key, Boolean hsm, KeyAttributesInner keyAttributes, Map<String, String> tags) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (keyName == null) {
            throw new IllegalArgumentException("Parameter keyName is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        if (key == null) {
            throw new IllegalArgumentException("Parameter key is required and cannot be null.");
        }
        Validator.validate(key);
        Validator.validate(keyAttributes);
        Validator.validate(tags);
        KeyImportParameters parameters = new KeyImportParameters();
        parameters.setHsm(hsm);
        parameters.setKey(key);
        parameters.setKeyAttributes(keyAttributes);
        parameters.setTags(tags);
        this.restClient().setBaseUrl("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.importKey(keyName, this.apiVersion(), this.acceptLanguage(), parameters, this.userAgent());
        return importKeyDelegate(call.execute());
    }

    /**
     * Imports a key into the specified vault.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param keyName The name of the key
     * @param key The Json web key
     * @param hsm Whether to import as a hardware key (HSM) or software key
     * @param keyAttributes The key management attributes
     * @param tags Application-specific metadata in the form of key-value pairs
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if callback is null
     * @return the {@link Call} object
     */
    public ServiceCall importKeyAsync(String vaultBaseUrl, String keyName, JsonWebKeyInner key, Boolean hsm, KeyAttributesInner keyAttributes, Map<String, String> tags, final ServiceCallback<KeyBundleInner> serviceCallback) throws IllegalArgumentException {
        if (serviceCallback == null) {
            throw new IllegalArgumentException("ServiceCallback is required for async calls.");
        }
        if (vaultBaseUrl == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null."));
            return null;
        }
        if (keyName == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter keyName is required and cannot be null."));
            return null;
        }
        if (this.apiVersion() == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null."));
            return null;
        }
        if (key == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter key is required and cannot be null."));
            return null;
        }
        Validator.validate(key, serviceCallback);
        Validator.validate(keyAttributes, serviceCallback);
        Validator.validate(tags, serviceCallback);
        KeyImportParameters parameters = new KeyImportParameters();
        parameters.setHsm(hsm);
        parameters.setKey(key);
        parameters.setKeyAttributes(keyAttributes);
        parameters.setTags(tags);
        this.restClient().setBaseUrl("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.importKey(keyName, this.apiVersion(), this.acceptLanguage(), parameters, this.userAgent());
        final ServiceCall serviceCall = new ServiceCall(call);
        call.enqueue(new ServiceResponseCallback<KeyBundleInner>(serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    serviceCallback.success(importKeyDelegate(response));
                } catch (KeyVaultErrorException | IOException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<KeyBundleInner> importKeyDelegate(Response<ResponseBody> response) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<KeyBundleInner, KeyVaultErrorException>(this.restClient().mapperAdapter())
                .register(200, new TypeToken<KeyBundleInner>() { }.getType())
                .registerError(KeyVaultErrorException.class)
                .build(response);
    }

    /**
     * Deletes the specified key.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param keyName The name of the key
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the KeyBundleInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<KeyBundleInner> deleteKey(String vaultBaseUrl, String keyName) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (keyName == null) {
            throw new IllegalArgumentException("Parameter keyName is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        this.restClient().setBaseUrl("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.deleteKey(keyName, this.apiVersion(), this.acceptLanguage(), this.userAgent());
        return deleteKeyDelegate(call.execute());
    }

    /**
     * Deletes the specified key.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param keyName The name of the key
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if callback is null
     * @return the {@link Call} object
     */
    public ServiceCall deleteKeyAsync(String vaultBaseUrl, String keyName, final ServiceCallback<KeyBundleInner> serviceCallback) throws IllegalArgumentException {
        if (serviceCallback == null) {
            throw new IllegalArgumentException("ServiceCallback is required for async calls.");
        }
        if (vaultBaseUrl == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null."));
            return null;
        }
        if (keyName == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter keyName is required and cannot be null."));
            return null;
        }
        if (this.apiVersion() == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null."));
            return null;
        }
        this.restClient().setBaseUrl("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.deleteKey(keyName, this.apiVersion(), this.acceptLanguage(), this.userAgent());
        final ServiceCall serviceCall = new ServiceCall(call);
        call.enqueue(new ServiceResponseCallback<KeyBundleInner>(serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    serviceCallback.success(deleteKeyDelegate(response));
                } catch (KeyVaultErrorException | IOException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<KeyBundleInner> deleteKeyDelegate(Response<ResponseBody> response) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<KeyBundleInner, KeyVaultErrorException>(this.restClient().mapperAdapter())
                .register(200, new TypeToken<KeyBundleInner>() { }.getType())
                .registerError(KeyVaultErrorException.class)
                .build(response);
    }

    /**
     * Updates the Key Attributes associated with the specified key.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param keyName The name of the key
     * @param keyVersion The version of the key
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the KeyBundleInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<KeyBundleInner> updateKey(String vaultBaseUrl, String keyName, String keyVersion) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (keyName == null) {
            throw new IllegalArgumentException("Parameter keyName is required and cannot be null.");
        }
        if (keyVersion == null) {
            throw new IllegalArgumentException("Parameter keyVersion is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        final String keyOpsConverted = null;
        final KeyAttributesInner keyAttributes = null;
        final Map<String, String> tags = null;
        KeyUpdateParameters parameters = new KeyUpdateParameters();
        parameters.setKeyOps(null);
        parameters.setKeyAttributes(null);
        parameters.setTags(null);
        this.restClient().setBaseUrl("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.updateKey(keyName, keyVersion, this.apiVersion(), this.acceptLanguage(), parameters, this.userAgent());
        return updateKeyDelegate(call.execute());
    }

    /**
     * Updates the Key Attributes associated with the specified key.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param keyName The name of the key
     * @param keyVersion The version of the key
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if callback is null
     * @return the {@link Call} object
     */
    public ServiceCall updateKeyAsync(String vaultBaseUrl, String keyName, String keyVersion, final ServiceCallback<KeyBundleInner> serviceCallback) throws IllegalArgumentException {
        if (serviceCallback == null) {
            throw new IllegalArgumentException("ServiceCallback is required for async calls.");
        }
        if (vaultBaseUrl == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null."));
            return null;
        }
        if (keyName == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter keyName is required and cannot be null."));
            return null;
        }
        if (keyVersion == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter keyVersion is required and cannot be null."));
            return null;
        }
        if (this.apiVersion() == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null."));
            return null;
        }
        final String keyOpsConverted = null;
        final KeyAttributesInner keyAttributes = null;
        final Map<String, String> tags = null;
        KeyUpdateParameters parameters = new KeyUpdateParameters();
        parameters.setKeyOps(null);
        parameters.setKeyAttributes(null);
        parameters.setTags(null);
        this.restClient().setBaseUrl("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.updateKey(keyName, keyVersion, this.apiVersion(), this.acceptLanguage(), parameters, this.userAgent());
        final ServiceCall serviceCall = new ServiceCall(call);
        call.enqueue(new ServiceResponseCallback<KeyBundleInner>(serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    serviceCallback.success(updateKeyDelegate(response));
                } catch (KeyVaultErrorException | IOException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    /**
     * Updates the Key Attributes associated with the specified key.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param keyName The name of the key
     * @param keyVersion The version of the key
     * @param keyOps Json web key operations. For more information on possible key operations, see JsonWebKeyOperation.
     * @param keyAttributes the KeyAttributesInner value
     * @param tags Application-specific metadata in the form of key-value pairs
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the KeyBundleInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<KeyBundleInner> updateKey(String vaultBaseUrl, String keyName, String keyVersion, List<String> keyOps, KeyAttributesInner keyAttributes, Map<String, String> tags) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (keyName == null) {
            throw new IllegalArgumentException("Parameter keyName is required and cannot be null.");
        }
        if (keyVersion == null) {
            throw new IllegalArgumentException("Parameter keyVersion is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        Validator.validate(keyOps);
        Validator.validate(keyAttributes);
        Validator.validate(tags);
        KeyUpdateParameters parameters = new KeyUpdateParameters();
        parameters.setKeyOps(keyOps);
        parameters.setKeyAttributes(keyAttributes);
        parameters.setTags(tags);
        this.restClient().setBaseUrl("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.updateKey(keyName, keyVersion, this.apiVersion(), this.acceptLanguage(), parameters, this.userAgent());
        return updateKeyDelegate(call.execute());
    }

    /**
     * Updates the Key Attributes associated with the specified key.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param keyName The name of the key
     * @param keyVersion The version of the key
     * @param keyOps Json web key operations. For more information on possible key operations, see JsonWebKeyOperation.
     * @param keyAttributes the KeyAttributesInner value
     * @param tags Application-specific metadata in the form of key-value pairs
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if callback is null
     * @return the {@link Call} object
     */
    public ServiceCall updateKeyAsync(String vaultBaseUrl, String keyName, String keyVersion, List<String> keyOps, KeyAttributesInner keyAttributes, Map<String, String> tags, final ServiceCallback<KeyBundleInner> serviceCallback) throws IllegalArgumentException {
        if (serviceCallback == null) {
            throw new IllegalArgumentException("ServiceCallback is required for async calls.");
        }
        if (vaultBaseUrl == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null."));
            return null;
        }
        if (keyName == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter keyName is required and cannot be null."));
            return null;
        }
        if (keyVersion == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter keyVersion is required and cannot be null."));
            return null;
        }
        if (this.apiVersion() == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null."));
            return null;
        }
        Validator.validate(keyOps, serviceCallback);
        Validator.validate(keyAttributes, serviceCallback);
        Validator.validate(tags, serviceCallback);
        KeyUpdateParameters parameters = new KeyUpdateParameters();
        parameters.setKeyOps(keyOps);
        parameters.setKeyAttributes(keyAttributes);
        parameters.setTags(tags);
        this.restClient().setBaseUrl("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.updateKey(keyName, keyVersion, this.apiVersion(), this.acceptLanguage(), parameters, this.userAgent());
        final ServiceCall serviceCall = new ServiceCall(call);
        call.enqueue(new ServiceResponseCallback<KeyBundleInner>(serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    serviceCallback.success(updateKeyDelegate(response));
                } catch (KeyVaultErrorException | IOException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<KeyBundleInner> updateKeyDelegate(Response<ResponseBody> response) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<KeyBundleInner, KeyVaultErrorException>(this.restClient().mapperAdapter())
                .register(200, new TypeToken<KeyBundleInner>() { }.getType())
                .registerError(KeyVaultErrorException.class)
                .build(response);
    }

    /**
     * Retrieves the public portion of a key plus its attributes.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param keyName The name of the key
     * @param keyVersion The version of the key
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the KeyBundleInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<KeyBundleInner> getKey(String vaultBaseUrl, String keyName, String keyVersion) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (keyName == null) {
            throw new IllegalArgumentException("Parameter keyName is required and cannot be null.");
        }
        if (keyVersion == null) {
            throw new IllegalArgumentException("Parameter keyVersion is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        this.restClient().setBaseUrl("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.getKey(keyName, keyVersion, this.apiVersion(), this.acceptLanguage(), this.userAgent());
        return getKeyDelegate(call.execute());
    }

    /**
     * Retrieves the public portion of a key plus its attributes.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param keyName The name of the key
     * @param keyVersion The version of the key
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if callback is null
     * @return the {@link Call} object
     */
    public ServiceCall getKeyAsync(String vaultBaseUrl, String keyName, String keyVersion, final ServiceCallback<KeyBundleInner> serviceCallback) throws IllegalArgumentException {
        if (serviceCallback == null) {
            throw new IllegalArgumentException("ServiceCallback is required for async calls.");
        }
        if (vaultBaseUrl == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null."));
            return null;
        }
        if (keyName == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter keyName is required and cannot be null."));
            return null;
        }
        if (keyVersion == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter keyVersion is required and cannot be null."));
            return null;
        }
        if (this.apiVersion() == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null."));
            return null;
        }
        this.restClient().setBaseUrl("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.getKey(keyName, keyVersion, this.apiVersion(), this.acceptLanguage(), this.userAgent());
        final ServiceCall serviceCall = new ServiceCall(call);
        call.enqueue(new ServiceResponseCallback<KeyBundleInner>(serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    serviceCallback.success(getKeyDelegate(response));
                } catch (KeyVaultErrorException | IOException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<KeyBundleInner> getKeyDelegate(Response<ResponseBody> response) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<KeyBundleInner, KeyVaultErrorException>(this.restClient().mapperAdapter())
                .register(200, new TypeToken<KeyBundleInner>() { }.getType())
                .registerError(KeyVaultErrorException.class)
                .build(response);
    }

    /**
     * List the versions of the specified key.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param keyName The name of the key
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;KeyItemInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PagedList<KeyItemInner>> getKeyVersions(final String vaultBaseUrl, final String keyName) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (keyName == null) {
            throw new IllegalArgumentException("Parameter keyName is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        final Integer maxresults = null;
        this.restClient().setBaseUrl("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.getKeyVersions(keyName, maxresults, this.apiVersion(), this.acceptLanguage(), this.userAgent());
        ServiceResponse<PageImpl<KeyItemInner>> response = getKeyVersionsDelegate(call.execute());
        PagedList<KeyItemInner> result = new PagedList<KeyItemInner>(response.getBody()) {
            @Override
            public Page<KeyItemInner> nextPage(String nextPageLink) throws KeyVaultErrorException, IOException {
                return getKeyVersionsNext(nextPageLink).getBody();
            }
        };
        return new ServiceResponse<>(result, response.getResponse());
    }

    /**
     * List the versions of the specified key.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param keyName The name of the key
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if callback is null
     * @return the {@link Call} object
     */
    public ServiceCall getKeyVersionsAsync(final String vaultBaseUrl, final String keyName, final ListOperationCallback<KeyItemInner> serviceCallback) throws IllegalArgumentException {
        if (serviceCallback == null) {
            throw new IllegalArgumentException("ServiceCallback is required for async calls.");
        }
        if (vaultBaseUrl == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null."));
            return null;
        }
        if (keyName == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter keyName is required and cannot be null."));
            return null;
        }
        if (this.apiVersion() == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null."));
            return null;
        }
        final Integer maxresults = null;
        this.restClient().setBaseUrl("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.getKeyVersions(keyName, maxresults, this.apiVersion(), this.acceptLanguage(), this.userAgent());
        final ServiceCall serviceCall = new ServiceCall(call);
        call.enqueue(new ServiceResponseCallback<List<KeyItemInner>>(serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<PageImpl<KeyItemInner>> result = getKeyVersionsDelegate(response);
                    serviceCallback.load(result.getBody().getItems());
                    if (result.getBody().getNextPageLink() != null
                            && serviceCallback.progress(result.getBody().getItems()) == ListOperationCallback.PagingBahavior.CONTINUE) {
                        getKeyVersionsNextAsync(result.getBody().getNextPageLink(), serviceCall, serviceCallback);
                    } else {
                        serviceCallback.success(new ServiceResponse<>(serviceCallback.get(), result.getResponse()));
                    }
                } catch (KeyVaultErrorException | IOException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    /**
     * List the versions of the specified key.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param keyName The name of the key
     * @param maxresults Maximum number of results to return.
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;KeyItemInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PagedList<KeyItemInner>> getKeyVersions(final String vaultBaseUrl, final String keyName, final Integer maxresults) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (keyName == null) {
            throw new IllegalArgumentException("Parameter keyName is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        this.restClient().setBaseUrl("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.getKeyVersions(keyName, maxresults, this.apiVersion(), this.acceptLanguage(), this.userAgent());
        ServiceResponse<PageImpl<KeyItemInner>> response = getKeyVersionsDelegate(call.execute());
        PagedList<KeyItemInner> result = new PagedList<KeyItemInner>(response.getBody()) {
            @Override
            public Page<KeyItemInner> nextPage(String nextPageLink) throws KeyVaultErrorException, IOException {
                return getKeyVersionsNext(nextPageLink).getBody();
            }
        };
        return new ServiceResponse<>(result, response.getResponse());
    }

    /**
     * List the versions of the specified key.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param keyName The name of the key
     * @param maxresults Maximum number of results to return.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if callback is null
     * @return the {@link Call} object
     */
    public ServiceCall getKeyVersionsAsync(final String vaultBaseUrl, final String keyName, final Integer maxresults, final ListOperationCallback<KeyItemInner> serviceCallback) throws IllegalArgumentException {
        if (serviceCallback == null) {
            throw new IllegalArgumentException("ServiceCallback is required for async calls.");
        }
        if (vaultBaseUrl == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null."));
            return null;
        }
        if (keyName == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter keyName is required and cannot be null."));
            return null;
        }
        if (this.apiVersion() == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null."));
            return null;
        }
        this.restClient().setBaseUrl("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.getKeyVersions(keyName, maxresults, this.apiVersion(), this.acceptLanguage(), this.userAgent());
        final ServiceCall serviceCall = new ServiceCall(call);
        call.enqueue(new ServiceResponseCallback<List<KeyItemInner>>(serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<PageImpl<KeyItemInner>> result = getKeyVersionsDelegate(response);
                    serviceCallback.load(result.getBody().getItems());
                    if (result.getBody().getNextPageLink() != null
                            && serviceCallback.progress(result.getBody().getItems()) == ListOperationCallback.PagingBahavior.CONTINUE) {
                        getKeyVersionsNextAsync(result.getBody().getNextPageLink(), serviceCall, serviceCallback);
                    } else {
                        serviceCallback.success(new ServiceResponse<>(serviceCallback.get(), result.getResponse()));
                    }
                } catch (KeyVaultErrorException | IOException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<PageImpl<KeyItemInner>> getKeyVersionsDelegate(Response<ResponseBody> response) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<KeyItemInner>, KeyVaultErrorException>(this.restClient().mapperAdapter())
                .register(200, new TypeToken<PageImpl<KeyItemInner>>() { }.getType())
                .registerError(KeyVaultErrorException.class)
                .build(response);
    }

    /**
     * List keys in the specified vault.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;KeyItemInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PagedList<KeyItemInner>> getKeys(final String vaultBaseUrl) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        final Integer maxresults = null;
        this.restClient().setBaseUrl("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.getKeys(maxresults, this.apiVersion(), this.acceptLanguage(), this.userAgent());
        ServiceResponse<PageImpl<KeyItemInner>> response = getKeysDelegate(call.execute());
        PagedList<KeyItemInner> result = new PagedList<KeyItemInner>(response.getBody()) {
            @Override
            public Page<KeyItemInner> nextPage(String nextPageLink) throws KeyVaultErrorException, IOException {
                return getKeysNext(nextPageLink).getBody();
            }
        };
        return new ServiceResponse<>(result, response.getResponse());
    }

    /**
     * List keys in the specified vault.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if callback is null
     * @return the {@link Call} object
     */
    public ServiceCall getKeysAsync(final String vaultBaseUrl, final ListOperationCallback<KeyItemInner> serviceCallback) throws IllegalArgumentException {
        if (serviceCallback == null) {
            throw new IllegalArgumentException("ServiceCallback is required for async calls.");
        }
        if (vaultBaseUrl == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null."));
            return null;
        }
        if (this.apiVersion() == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null."));
            return null;
        }
        final Integer maxresults = null;
        this.restClient().setBaseUrl("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.getKeys(maxresults, this.apiVersion(), this.acceptLanguage(), this.userAgent());
        final ServiceCall serviceCall = new ServiceCall(call);
        call.enqueue(new ServiceResponseCallback<List<KeyItemInner>>(serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<PageImpl<KeyItemInner>> result = getKeysDelegate(response);
                    serviceCallback.load(result.getBody().getItems());
                    if (result.getBody().getNextPageLink() != null
                            && serviceCallback.progress(result.getBody().getItems()) == ListOperationCallback.PagingBahavior.CONTINUE) {
                        getKeysNextAsync(result.getBody().getNextPageLink(), serviceCall, serviceCallback);
                    } else {
                        serviceCallback.success(new ServiceResponse<>(serviceCallback.get(), result.getResponse()));
                    }
                } catch (KeyVaultErrorException | IOException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    /**
     * List keys in the specified vault.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param maxresults Maximum number of results to return.
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;KeyItemInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PagedList<KeyItemInner>> getKeys(final String vaultBaseUrl, final Integer maxresults) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        this.restClient().setBaseUrl("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.getKeys(maxresults, this.apiVersion(), this.acceptLanguage(), this.userAgent());
        ServiceResponse<PageImpl<KeyItemInner>> response = getKeysDelegate(call.execute());
        PagedList<KeyItemInner> result = new PagedList<KeyItemInner>(response.getBody()) {
            @Override
            public Page<KeyItemInner> nextPage(String nextPageLink) throws KeyVaultErrorException, IOException {
                return getKeysNext(nextPageLink).getBody();
            }
        };
        return new ServiceResponse<>(result, response.getResponse());
    }

    /**
     * List keys in the specified vault.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param maxresults Maximum number of results to return.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if callback is null
     * @return the {@link Call} object
     */
    public ServiceCall getKeysAsync(final String vaultBaseUrl, final Integer maxresults, final ListOperationCallback<KeyItemInner> serviceCallback) throws IllegalArgumentException {
        if (serviceCallback == null) {
            throw new IllegalArgumentException("ServiceCallback is required for async calls.");
        }
        if (vaultBaseUrl == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null."));
            return null;
        }
        if (this.apiVersion() == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null."));
            return null;
        }
        this.restClient().setBaseUrl("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.getKeys(maxresults, this.apiVersion(), this.acceptLanguage(), this.userAgent());
        final ServiceCall serviceCall = new ServiceCall(call);
        call.enqueue(new ServiceResponseCallback<List<KeyItemInner>>(serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<PageImpl<KeyItemInner>> result = getKeysDelegate(response);
                    serviceCallback.load(result.getBody().getItems());
                    if (result.getBody().getNextPageLink() != null
                            && serviceCallback.progress(result.getBody().getItems()) == ListOperationCallback.PagingBahavior.CONTINUE) {
                        getKeysNextAsync(result.getBody().getNextPageLink(), serviceCall, serviceCallback);
                    } else {
                        serviceCallback.success(new ServiceResponse<>(serviceCallback.get(), result.getResponse()));
                    }
                } catch (KeyVaultErrorException | IOException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<PageImpl<KeyItemInner>> getKeysDelegate(Response<ResponseBody> response) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<KeyItemInner>, KeyVaultErrorException>(this.restClient().mapperAdapter())
                .register(200, new TypeToken<PageImpl<KeyItemInner>>() { }.getType())
                .registerError(KeyVaultErrorException.class)
                .build(response);
    }

    /**
     * Requests that a backup of the specified key be downloaded to the client.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param keyName The name of the key
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the BackupKeyResultInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<BackupKeyResultInner> backupKey(String vaultBaseUrl, String keyName) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (keyName == null) {
            throw new IllegalArgumentException("Parameter keyName is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        this.restClient().setBaseUrl("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.backupKey(keyName, this.apiVersion(), this.acceptLanguage(), this.userAgent());
        return backupKeyDelegate(call.execute());
    }

    /**
     * Requests that a backup of the specified key be downloaded to the client.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param keyName The name of the key
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if callback is null
     * @return the {@link Call} object
     */
    public ServiceCall backupKeyAsync(String vaultBaseUrl, String keyName, final ServiceCallback<BackupKeyResultInner> serviceCallback) throws IllegalArgumentException {
        if (serviceCallback == null) {
            throw new IllegalArgumentException("ServiceCallback is required for async calls.");
        }
        if (vaultBaseUrl == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null."));
            return null;
        }
        if (keyName == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter keyName is required and cannot be null."));
            return null;
        }
        if (this.apiVersion() == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null."));
            return null;
        }
        this.restClient().setBaseUrl("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.backupKey(keyName, this.apiVersion(), this.acceptLanguage(), this.userAgent());
        final ServiceCall serviceCall = new ServiceCall(call);
        call.enqueue(new ServiceResponseCallback<BackupKeyResultInner>(serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    serviceCallback.success(backupKeyDelegate(response));
                } catch (KeyVaultErrorException | IOException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<BackupKeyResultInner> backupKeyDelegate(Response<ResponseBody> response) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<BackupKeyResultInner, KeyVaultErrorException>(this.restClient().mapperAdapter())
                .register(200, new TypeToken<BackupKeyResultInner>() { }.getType())
                .registerError(KeyVaultErrorException.class)
                .build(response);
    }

    /**
     * Restores the backup key in to a vault.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param keyBundleBackup the backup blob associated with a key bundle
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the KeyBundleInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<KeyBundleInner> restoreKey(String vaultBaseUrl, String keyBundleBackup) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        if (keyBundleBackup == null) {
            throw new IllegalArgumentException("Parameter keyBundleBackup is required and cannot be null.");
        }
        KeyRestoreParameters parameters = new KeyRestoreParameters();
        parameters.setKeyBundleBackup(keyBundleBackup);
        this.restClient().setBaseUrl("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.restoreKey(this.apiVersion(), this.acceptLanguage(), parameters, this.userAgent());
        return restoreKeyDelegate(call.execute());
    }

    /**
     * Restores the backup key in to a vault.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param keyBundleBackup the backup blob associated with a key bundle
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if callback is null
     * @return the {@link Call} object
     */
    public ServiceCall restoreKeyAsync(String vaultBaseUrl, String keyBundleBackup, final ServiceCallback<KeyBundleInner> serviceCallback) throws IllegalArgumentException {
        if (serviceCallback == null) {
            throw new IllegalArgumentException("ServiceCallback is required for async calls.");
        }
        if (vaultBaseUrl == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null."));
            return null;
        }
        if (this.apiVersion() == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null."));
            return null;
        }
        if (keyBundleBackup == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter keyBundleBackup is required and cannot be null."));
            return null;
        }
        KeyRestoreParameters parameters = new KeyRestoreParameters();
        parameters.setKeyBundleBackup(keyBundleBackup);
        this.restClient().setBaseUrl("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.restoreKey(this.apiVersion(), this.acceptLanguage(), parameters, this.userAgent());
        final ServiceCall serviceCall = new ServiceCall(call);
        call.enqueue(new ServiceResponseCallback<KeyBundleInner>(serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    serviceCallback.success(restoreKeyDelegate(response));
                } catch (KeyVaultErrorException | IOException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<KeyBundleInner> restoreKeyDelegate(Response<ResponseBody> response) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<KeyBundleInner, KeyVaultErrorException>(this.restClient().mapperAdapter())
                .register(200, new TypeToken<KeyBundleInner>() { }.getType())
                .registerError(KeyVaultErrorException.class)
                .build(response);
    }

    /**
     * Encrypts a single block of data. The amount of data that may be encrypted is determined.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param keyName The name of the key
     * @param keyVersion The version of the key
     * @param algorithm algorithm identifier
     * @param value the String value
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the KeyOperationResultInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<KeyOperationResultInner> encrypt(String vaultBaseUrl, String keyName, String keyVersion, String algorithm, String value) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (keyName == null) {
            throw new IllegalArgumentException("Parameter keyName is required and cannot be null.");
        }
        if (keyVersion == null) {
            throw new IllegalArgumentException("Parameter keyVersion is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        if (algorithm == null) {
            throw new IllegalArgumentException("Parameter algorithm is required and cannot be null.");
        }
        if (value == null) {
            throw new IllegalArgumentException("Parameter value is required and cannot be null.");
        }
        KeyOperationsParameters parameters = new KeyOperationsParameters();
        parameters.setAlgorithm(algorithm);
        parameters.setValue(value);
        this.restClient().setBaseUrl("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.encrypt(keyName, keyVersion, this.apiVersion(), this.acceptLanguage(), parameters, this.userAgent());
        return encryptDelegate(call.execute());
    }

    /**
     * Encrypts a single block of data. The amount of data that may be encrypted is determined.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param keyName The name of the key
     * @param keyVersion The version of the key
     * @param algorithm algorithm identifier
     * @param value the String value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if callback is null
     * @return the {@link Call} object
     */
    public ServiceCall encryptAsync(String vaultBaseUrl, String keyName, String keyVersion, String algorithm, String value, final ServiceCallback<KeyOperationResultInner> serviceCallback) throws IllegalArgumentException {
        if (serviceCallback == null) {
            throw new IllegalArgumentException("ServiceCallback is required for async calls.");
        }
        if (vaultBaseUrl == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null."));
            return null;
        }
        if (keyName == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter keyName is required and cannot be null."));
            return null;
        }
        if (keyVersion == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter keyVersion is required and cannot be null."));
            return null;
        }
        if (this.apiVersion() == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null."));
            return null;
        }
        if (algorithm == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter algorithm is required and cannot be null."));
            return null;
        }
        if (value == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter value is required and cannot be null."));
            return null;
        }
        KeyOperationsParameters parameters = new KeyOperationsParameters();
        parameters.setAlgorithm(algorithm);
        parameters.setValue(value);
        this.restClient().setBaseUrl("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.encrypt(keyName, keyVersion, this.apiVersion(), this.acceptLanguage(), parameters, this.userAgent());
        final ServiceCall serviceCall = new ServiceCall(call);
        call.enqueue(new ServiceResponseCallback<KeyOperationResultInner>(serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    serviceCallback.success(encryptDelegate(response));
                } catch (KeyVaultErrorException | IOException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<KeyOperationResultInner> encryptDelegate(Response<ResponseBody> response) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<KeyOperationResultInner, KeyVaultErrorException>(this.restClient().mapperAdapter())
                .register(200, new TypeToken<KeyOperationResultInner>() { }.getType())
                .registerError(KeyVaultErrorException.class)
                .build(response);
    }

    /**
     * Decrypts a single block of encrypted data.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param keyName The name of the key
     * @param keyVersion The version of the key
     * @param algorithm algorithm identifier
     * @param value the String value
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the KeyOperationResultInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<KeyOperationResultInner> decrypt(String vaultBaseUrl, String keyName, String keyVersion, String algorithm, String value) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (keyName == null) {
            throw new IllegalArgumentException("Parameter keyName is required and cannot be null.");
        }
        if (keyVersion == null) {
            throw new IllegalArgumentException("Parameter keyVersion is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        if (algorithm == null) {
            throw new IllegalArgumentException("Parameter algorithm is required and cannot be null.");
        }
        if (value == null) {
            throw new IllegalArgumentException("Parameter value is required and cannot be null.");
        }
        KeyOperationsParameters parameters = new KeyOperationsParameters();
        parameters.setAlgorithm(algorithm);
        parameters.setValue(value);
        this.restClient().setBaseUrl("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.decrypt(keyName, keyVersion, this.apiVersion(), this.acceptLanguage(), parameters, this.userAgent());
        return decryptDelegate(call.execute());
    }

    /**
     * Decrypts a single block of encrypted data.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param keyName The name of the key
     * @param keyVersion The version of the key
     * @param algorithm algorithm identifier
     * @param value the String value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if callback is null
     * @return the {@link Call} object
     */
    public ServiceCall decryptAsync(String vaultBaseUrl, String keyName, String keyVersion, String algorithm, String value, final ServiceCallback<KeyOperationResultInner> serviceCallback) throws IllegalArgumentException {
        if (serviceCallback == null) {
            throw new IllegalArgumentException("ServiceCallback is required for async calls.");
        }
        if (vaultBaseUrl == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null."));
            return null;
        }
        if (keyName == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter keyName is required and cannot be null."));
            return null;
        }
        if (keyVersion == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter keyVersion is required and cannot be null."));
            return null;
        }
        if (this.apiVersion() == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null."));
            return null;
        }
        if (algorithm == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter algorithm is required and cannot be null."));
            return null;
        }
        if (value == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter value is required and cannot be null."));
            return null;
        }
        KeyOperationsParameters parameters = new KeyOperationsParameters();
        parameters.setAlgorithm(algorithm);
        parameters.setValue(value);
        this.restClient().setBaseUrl("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.decrypt(keyName, keyVersion, this.apiVersion(), this.acceptLanguage(), parameters, this.userAgent());
        final ServiceCall serviceCall = new ServiceCall(call);
        call.enqueue(new ServiceResponseCallback<KeyOperationResultInner>(serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    serviceCallback.success(decryptDelegate(response));
                } catch (KeyVaultErrorException | IOException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<KeyOperationResultInner> decryptDelegate(Response<ResponseBody> response) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<KeyOperationResultInner, KeyVaultErrorException>(this.restClient().mapperAdapter())
                .register(200, new TypeToken<KeyOperationResultInner>() { }.getType())
                .registerError(KeyVaultErrorException.class)
                .build(response);
    }

    /**
     * Creates a signature from a digest using the specified key in the vault.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param keyName The name of the key
     * @param keyVersion The version of the key
     * @param algorithm algorithm identifier
     * @param value the String value
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the KeyOperationResultInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<KeyOperationResultInner> sign(String vaultBaseUrl, String keyName, String keyVersion, String algorithm, String value) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (keyName == null) {
            throw new IllegalArgumentException("Parameter keyName is required and cannot be null.");
        }
        if (keyVersion == null) {
            throw new IllegalArgumentException("Parameter keyVersion is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        if (algorithm == null) {
            throw new IllegalArgumentException("Parameter algorithm is required and cannot be null.");
        }
        if (value == null) {
            throw new IllegalArgumentException("Parameter value is required and cannot be null.");
        }
        KeyOperationsParameters parameters = new KeyOperationsParameters();
        parameters.setAlgorithm(algorithm);
        parameters.setValue(value);
        this.restClient().setBaseUrl("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.sign(keyName, keyVersion, this.apiVersion(), this.acceptLanguage(), parameters, this.userAgent());
        return signDelegate(call.execute());
    }

    /**
     * Creates a signature from a digest using the specified key in the vault.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param keyName The name of the key
     * @param keyVersion The version of the key
     * @param algorithm algorithm identifier
     * @param value the String value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if callback is null
     * @return the {@link Call} object
     */
    public ServiceCall signAsync(String vaultBaseUrl, String keyName, String keyVersion, String algorithm, String value, final ServiceCallback<KeyOperationResultInner> serviceCallback) throws IllegalArgumentException {
        if (serviceCallback == null) {
            throw new IllegalArgumentException("ServiceCallback is required for async calls.");
        }
        if (vaultBaseUrl == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null."));
            return null;
        }
        if (keyName == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter keyName is required and cannot be null."));
            return null;
        }
        if (keyVersion == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter keyVersion is required and cannot be null."));
            return null;
        }
        if (this.apiVersion() == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null."));
            return null;
        }
        if (algorithm == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter algorithm is required and cannot be null."));
            return null;
        }
        if (value == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter value is required and cannot be null."));
            return null;
        }
        KeyOperationsParameters parameters = new KeyOperationsParameters();
        parameters.setAlgorithm(algorithm);
        parameters.setValue(value);
        this.restClient().setBaseUrl("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.sign(keyName, keyVersion, this.apiVersion(), this.acceptLanguage(), parameters, this.userAgent());
        final ServiceCall serviceCall = new ServiceCall(call);
        call.enqueue(new ServiceResponseCallback<KeyOperationResultInner>(serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    serviceCallback.success(signDelegate(response));
                } catch (KeyVaultErrorException | IOException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<KeyOperationResultInner> signDelegate(Response<ResponseBody> response) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<KeyOperationResultInner, KeyVaultErrorException>(this.restClient().mapperAdapter())
                .register(200, new TypeToken<KeyOperationResultInner>() { }.getType())
                .registerError(KeyVaultErrorException.class)
                .build(response);
    }

    /**
     * Verifies a signature using the specified key.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param keyName The name of the key
     * @param keyVersion The version of the key
     * @param algorithm The signing/verification algorithm. For more information on possible algorithm types, see JsonWebKeySignatureAlgorithm.
     * @param digest The digest used for signing
     * @param signature The signature to be verified
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the KeyVerifyResultInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<KeyVerifyResultInner> verify(String vaultBaseUrl, String keyName, String keyVersion, String algorithm, String digest, String signature) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (keyName == null) {
            throw new IllegalArgumentException("Parameter keyName is required and cannot be null.");
        }
        if (keyVersion == null) {
            throw new IllegalArgumentException("Parameter keyVersion is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        if (algorithm == null) {
            throw new IllegalArgumentException("Parameter algorithm is required and cannot be null.");
        }
        if (digest == null) {
            throw new IllegalArgumentException("Parameter digest is required and cannot be null.");
        }
        if (signature == null) {
            throw new IllegalArgumentException("Parameter signature is required and cannot be null.");
        }
        KeyVerifyParameters parameters = new KeyVerifyParameters();
        parameters.setAlgorithm(algorithm);
        parameters.setDigest(digest);
        parameters.setSignature(signature);
        this.restClient().setBaseUrl("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.verify(keyName, keyVersion, this.apiVersion(), this.acceptLanguage(), parameters, this.userAgent());
        return verifyDelegate(call.execute());
    }

    /**
     * Verifies a signature using the specified key.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param keyName The name of the key
     * @param keyVersion The version of the key
     * @param algorithm The signing/verification algorithm. For more information on possible algorithm types, see JsonWebKeySignatureAlgorithm.
     * @param digest The digest used for signing
     * @param signature The signature to be verified
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if callback is null
     * @return the {@link Call} object
     */
    public ServiceCall verifyAsync(String vaultBaseUrl, String keyName, String keyVersion, String algorithm, String digest, String signature, final ServiceCallback<KeyVerifyResultInner> serviceCallback) throws IllegalArgumentException {
        if (serviceCallback == null) {
            throw new IllegalArgumentException("ServiceCallback is required for async calls.");
        }
        if (vaultBaseUrl == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null."));
            return null;
        }
        if (keyName == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter keyName is required and cannot be null."));
            return null;
        }
        if (keyVersion == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter keyVersion is required and cannot be null."));
            return null;
        }
        if (this.apiVersion() == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null."));
            return null;
        }
        if (algorithm == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter algorithm is required and cannot be null."));
            return null;
        }
        if (digest == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter digest is required and cannot be null."));
            return null;
        }
        if (signature == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter signature is required and cannot be null."));
            return null;
        }
        KeyVerifyParameters parameters = new KeyVerifyParameters();
        parameters.setAlgorithm(algorithm);
        parameters.setDigest(digest);
        parameters.setSignature(signature);
        this.restClient().setBaseUrl("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.verify(keyName, keyVersion, this.apiVersion(), this.acceptLanguage(), parameters, this.userAgent());
        final ServiceCall serviceCall = new ServiceCall(call);
        call.enqueue(new ServiceResponseCallback<KeyVerifyResultInner>(serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    serviceCallback.success(verifyDelegate(response));
                } catch (KeyVaultErrorException | IOException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<KeyVerifyResultInner> verifyDelegate(Response<ResponseBody> response) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<KeyVerifyResultInner, KeyVaultErrorException>(this.restClient().mapperAdapter())
                .register(200, new TypeToken<KeyVerifyResultInner>() { }.getType())
                .registerError(KeyVaultErrorException.class)
                .build(response);
    }

    /**
     * Wraps a symmetric key using the specified key.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param keyName The name of the key
     * @param keyVersion The version of the key
     * @param algorithm algorithm identifier
     * @param value the String value
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the KeyOperationResultInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<KeyOperationResultInner> wrapKey(String vaultBaseUrl, String keyName, String keyVersion, String algorithm, String value) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (keyName == null) {
            throw new IllegalArgumentException("Parameter keyName is required and cannot be null.");
        }
        if (keyVersion == null) {
            throw new IllegalArgumentException("Parameter keyVersion is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        if (algorithm == null) {
            throw new IllegalArgumentException("Parameter algorithm is required and cannot be null.");
        }
        if (value == null) {
            throw new IllegalArgumentException("Parameter value is required and cannot be null.");
        }
        KeyOperationsParameters parameters = new KeyOperationsParameters();
        parameters.setAlgorithm(algorithm);
        parameters.setValue(value);
        this.restClient().setBaseUrl("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.wrapKey(keyName, keyVersion, this.apiVersion(), this.acceptLanguage(), parameters, this.userAgent());
        return wrapKeyDelegate(call.execute());
    }

    /**
     * Wraps a symmetric key using the specified key.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param keyName The name of the key
     * @param keyVersion The version of the key
     * @param algorithm algorithm identifier
     * @param value the String value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if callback is null
     * @return the {@link Call} object
     */
    public ServiceCall wrapKeyAsync(String vaultBaseUrl, String keyName, String keyVersion, String algorithm, String value, final ServiceCallback<KeyOperationResultInner> serviceCallback) throws IllegalArgumentException {
        if (serviceCallback == null) {
            throw new IllegalArgumentException("ServiceCallback is required for async calls.");
        }
        if (vaultBaseUrl == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null."));
            return null;
        }
        if (keyName == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter keyName is required and cannot be null."));
            return null;
        }
        if (keyVersion == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter keyVersion is required and cannot be null."));
            return null;
        }
        if (this.apiVersion() == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null."));
            return null;
        }
        if (algorithm == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter algorithm is required and cannot be null."));
            return null;
        }
        if (value == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter value is required and cannot be null."));
            return null;
        }
        KeyOperationsParameters parameters = new KeyOperationsParameters();
        parameters.setAlgorithm(algorithm);
        parameters.setValue(value);
        this.restClient().setBaseUrl("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.wrapKey(keyName, keyVersion, this.apiVersion(), this.acceptLanguage(), parameters, this.userAgent());
        final ServiceCall serviceCall = new ServiceCall(call);
        call.enqueue(new ServiceResponseCallback<KeyOperationResultInner>(serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    serviceCallback.success(wrapKeyDelegate(response));
                } catch (KeyVaultErrorException | IOException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<KeyOperationResultInner> wrapKeyDelegate(Response<ResponseBody> response) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<KeyOperationResultInner, KeyVaultErrorException>(this.restClient().mapperAdapter())
                .register(200, new TypeToken<KeyOperationResultInner>() { }.getType())
                .registerError(KeyVaultErrorException.class)
                .build(response);
    }

    /**
     * Unwraps a symmetric key using the specified key in the vault that has initially been used for wrapping the key.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param keyName The name of the key
     * @param keyVersion The version of the key
     * @param algorithm algorithm identifier
     * @param value the String value
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the KeyOperationResultInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<KeyOperationResultInner> unwrapKey(String vaultBaseUrl, String keyName, String keyVersion, String algorithm, String value) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (keyName == null) {
            throw new IllegalArgumentException("Parameter keyName is required and cannot be null.");
        }
        if (keyVersion == null) {
            throw new IllegalArgumentException("Parameter keyVersion is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        if (algorithm == null) {
            throw new IllegalArgumentException("Parameter algorithm is required and cannot be null.");
        }
        if (value == null) {
            throw new IllegalArgumentException("Parameter value is required and cannot be null.");
        }
        KeyOperationsParameters parameters = new KeyOperationsParameters();
        parameters.setAlgorithm(algorithm);
        parameters.setValue(value);
        this.restClient().setBaseUrl("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.unwrapKey(keyName, keyVersion, this.apiVersion(), this.acceptLanguage(), parameters, this.userAgent());
        return unwrapKeyDelegate(call.execute());
    }

    /**
     * Unwraps a symmetric key using the specified key in the vault that has initially been used for wrapping the key.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param keyName The name of the key
     * @param keyVersion The version of the key
     * @param algorithm algorithm identifier
     * @param value the String value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if callback is null
     * @return the {@link Call} object
     */
    public ServiceCall unwrapKeyAsync(String vaultBaseUrl, String keyName, String keyVersion, String algorithm, String value, final ServiceCallback<KeyOperationResultInner> serviceCallback) throws IllegalArgumentException {
        if (serviceCallback == null) {
            throw new IllegalArgumentException("ServiceCallback is required for async calls.");
        }
        if (vaultBaseUrl == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null."));
            return null;
        }
        if (keyName == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter keyName is required and cannot be null."));
            return null;
        }
        if (keyVersion == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter keyVersion is required and cannot be null."));
            return null;
        }
        if (this.apiVersion() == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null."));
            return null;
        }
        if (algorithm == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter algorithm is required and cannot be null."));
            return null;
        }
        if (value == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter value is required and cannot be null."));
            return null;
        }
        KeyOperationsParameters parameters = new KeyOperationsParameters();
        parameters.setAlgorithm(algorithm);
        parameters.setValue(value);
        this.restClient().setBaseUrl("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.unwrapKey(keyName, keyVersion, this.apiVersion(), this.acceptLanguage(), parameters, this.userAgent());
        final ServiceCall serviceCall = new ServiceCall(call);
        call.enqueue(new ServiceResponseCallback<KeyOperationResultInner>(serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    serviceCallback.success(unwrapKeyDelegate(response));
                } catch (KeyVaultErrorException | IOException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<KeyOperationResultInner> unwrapKeyDelegate(Response<ResponseBody> response) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<KeyOperationResultInner, KeyVaultErrorException>(this.restClient().mapperAdapter())
                .register(200, new TypeToken<KeyOperationResultInner>() { }.getType())
                .registerError(KeyVaultErrorException.class)
                .build(response);
    }

    /**
     * Sets a secret in the specified vault.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param secretName The name of the secret in the given vault
     * @param value The value of the secret
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the SecretBundleInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<SecretBundleInner> setSecret(String vaultBaseUrl, String secretName, String value) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (secretName == null) {
            throw new IllegalArgumentException("Parameter secretName is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        if (value == null) {
            throw new IllegalArgumentException("Parameter value is required and cannot be null.");
        }
        final Map<String, String> tags = null;
        final String contentType = null;
        final SecretAttributesInner secretAttributes = null;
        SecretSetParameters parameters = new SecretSetParameters();
        parameters.setValue(value);
        parameters.setTags(null);
        parameters.setContentType(null);
        parameters.setSecretAttributes(null);
        this.restClient().setBaseUrl("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.setSecret(secretName, this.apiVersion(), this.acceptLanguage(), parameters, this.userAgent());
        return setSecretDelegate(call.execute());
    }

    /**
     * Sets a secret in the specified vault.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param secretName The name of the secret in the given vault
     * @param value The value of the secret
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if callback is null
     * @return the {@link Call} object
     */
    public ServiceCall setSecretAsync(String vaultBaseUrl, String secretName, String value, final ServiceCallback<SecretBundleInner> serviceCallback) throws IllegalArgumentException {
        if (serviceCallback == null) {
            throw new IllegalArgumentException("ServiceCallback is required for async calls.");
        }
        if (vaultBaseUrl == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null."));
            return null;
        }
        if (secretName == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter secretName is required and cannot be null."));
            return null;
        }
        if (this.apiVersion() == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null."));
            return null;
        }
        if (value == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter value is required and cannot be null."));
            return null;
        }
        final Map<String, String> tags = null;
        final String contentType = null;
        final SecretAttributesInner secretAttributes = null;
        SecretSetParameters parameters = new SecretSetParameters();
        parameters.setValue(value);
        parameters.setTags(null);
        parameters.setContentType(null);
        parameters.setSecretAttributes(null);
        this.restClient().setBaseUrl("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.setSecret(secretName, this.apiVersion(), this.acceptLanguage(), parameters, this.userAgent());
        final ServiceCall serviceCall = new ServiceCall(call);
        call.enqueue(new ServiceResponseCallback<SecretBundleInner>(serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    serviceCallback.success(setSecretDelegate(response));
                } catch (KeyVaultErrorException | IOException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    /**
     * Sets a secret in the specified vault.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param secretName The name of the secret in the given vault
     * @param value The value of the secret
     * @param tags Application-specific metadata in the form of key-value pairs
     * @param contentType Type of the secret value such as a password
     * @param secretAttributes the SecretAttributesInner value
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the SecretBundleInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<SecretBundleInner> setSecret(String vaultBaseUrl, String secretName, String value, Map<String, String> tags, String contentType, SecretAttributesInner secretAttributes) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (secretName == null) {
            throw new IllegalArgumentException("Parameter secretName is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        if (value == null) {
            throw new IllegalArgumentException("Parameter value is required and cannot be null.");
        }
        Validator.validate(tags);
        Validator.validate(secretAttributes);
        SecretSetParameters parameters = new SecretSetParameters();
        parameters.setValue(value);
        parameters.setTags(tags);
        parameters.setContentType(contentType);
        parameters.setSecretAttributes(secretAttributes);
        this.restClient().setBaseUrl("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.setSecret(secretName, this.apiVersion(), this.acceptLanguage(), parameters, this.userAgent());
        return setSecretDelegate(call.execute());
    }

    /**
     * Sets a secret in the specified vault.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param secretName The name of the secret in the given vault
     * @param value The value of the secret
     * @param tags Application-specific metadata in the form of key-value pairs
     * @param contentType Type of the secret value such as a password
     * @param secretAttributes the SecretAttributesInner value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if callback is null
     * @return the {@link Call} object
     */
    public ServiceCall setSecretAsync(String vaultBaseUrl, String secretName, String value, Map<String, String> tags, String contentType, SecretAttributesInner secretAttributes, final ServiceCallback<SecretBundleInner> serviceCallback) throws IllegalArgumentException {
        if (serviceCallback == null) {
            throw new IllegalArgumentException("ServiceCallback is required for async calls.");
        }
        if (vaultBaseUrl == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null."));
            return null;
        }
        if (secretName == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter secretName is required and cannot be null."));
            return null;
        }
        if (this.apiVersion() == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null."));
            return null;
        }
        if (value == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter value is required and cannot be null."));
            return null;
        }
        Validator.validate(tags, serviceCallback);
        Validator.validate(secretAttributes, serviceCallback);
        SecretSetParameters parameters = new SecretSetParameters();
        parameters.setValue(value);
        parameters.setTags(tags);
        parameters.setContentType(contentType);
        parameters.setSecretAttributes(secretAttributes);
        this.restClient().setBaseUrl("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.setSecret(secretName, this.apiVersion(), this.acceptLanguage(), parameters, this.userAgent());
        final ServiceCall serviceCall = new ServiceCall(call);
        call.enqueue(new ServiceResponseCallback<SecretBundleInner>(serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    serviceCallback.success(setSecretDelegate(response));
                } catch (KeyVaultErrorException | IOException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<SecretBundleInner> setSecretDelegate(Response<ResponseBody> response) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<SecretBundleInner, KeyVaultErrorException>(this.restClient().mapperAdapter())
                .register(200, new TypeToken<SecretBundleInner>() { }.getType())
                .registerError(KeyVaultErrorException.class)
                .build(response);
    }

    /**
     * Deletes a secret from the specified vault.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param secretName The name of the secret in the given vault
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the SecretBundleInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<SecretBundleInner> deleteSecret(String vaultBaseUrl, String secretName) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (secretName == null) {
            throw new IllegalArgumentException("Parameter secretName is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        this.restClient().setBaseUrl("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.deleteSecret(secretName, this.apiVersion(), this.acceptLanguage(), this.userAgent());
        return deleteSecretDelegate(call.execute());
    }

    /**
     * Deletes a secret from the specified vault.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param secretName The name of the secret in the given vault
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if callback is null
     * @return the {@link Call} object
     */
    public ServiceCall deleteSecretAsync(String vaultBaseUrl, String secretName, final ServiceCallback<SecretBundleInner> serviceCallback) throws IllegalArgumentException {
        if (serviceCallback == null) {
            throw new IllegalArgumentException("ServiceCallback is required for async calls.");
        }
        if (vaultBaseUrl == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null."));
            return null;
        }
        if (secretName == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter secretName is required and cannot be null."));
            return null;
        }
        if (this.apiVersion() == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null."));
            return null;
        }
        this.restClient().setBaseUrl("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.deleteSecret(secretName, this.apiVersion(), this.acceptLanguage(), this.userAgent());
        final ServiceCall serviceCall = new ServiceCall(call);
        call.enqueue(new ServiceResponseCallback<SecretBundleInner>(serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    serviceCallback.success(deleteSecretDelegate(response));
                } catch (KeyVaultErrorException | IOException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<SecretBundleInner> deleteSecretDelegate(Response<ResponseBody> response) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<SecretBundleInner, KeyVaultErrorException>(this.restClient().mapperAdapter())
                .register(200, new TypeToken<SecretBundleInner>() { }.getType())
                .registerError(KeyVaultErrorException.class)
                .build(response);
    }

    /**
     * Updates the attributes associated with the specified secret.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param secretName The name of the secret in the given vault
     * @param secretVersion The version of the secret
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the SecretBundleInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<SecretBundleInner> updateSecret(String vaultBaseUrl, String secretName, String secretVersion) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (secretName == null) {
            throw new IllegalArgumentException("Parameter secretName is required and cannot be null.");
        }
        if (secretVersion == null) {
            throw new IllegalArgumentException("Parameter secretVersion is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        final String contentType = null;
        final SecretAttributesInner secretAttributes = null;
        final Map<String, String> tags = null;
        SecretUpdateParameters parameters = new SecretUpdateParameters();
        parameters.setContentType(null);
        parameters.setSecretAttributes(null);
        parameters.setTags(null);
        this.restClient().setBaseUrl("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.updateSecret(secretName, secretVersion, this.apiVersion(), this.acceptLanguage(), parameters, this.userAgent());
        return updateSecretDelegate(call.execute());
    }

    /**
     * Updates the attributes associated with the specified secret.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param secretName The name of the secret in the given vault
     * @param secretVersion The version of the secret
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if callback is null
     * @return the {@link Call} object
     */
    public ServiceCall updateSecretAsync(String vaultBaseUrl, String secretName, String secretVersion, final ServiceCallback<SecretBundleInner> serviceCallback) throws IllegalArgumentException {
        if (serviceCallback == null) {
            throw new IllegalArgumentException("ServiceCallback is required for async calls.");
        }
        if (vaultBaseUrl == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null."));
            return null;
        }
        if (secretName == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter secretName is required and cannot be null."));
            return null;
        }
        if (secretVersion == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter secretVersion is required and cannot be null."));
            return null;
        }
        if (this.apiVersion() == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null."));
            return null;
        }
        final String contentType = null;
        final SecretAttributesInner secretAttributes = null;
        final Map<String, String> tags = null;
        SecretUpdateParameters parameters = new SecretUpdateParameters();
        parameters.setContentType(null);
        parameters.setSecretAttributes(null);
        parameters.setTags(null);
        this.restClient().setBaseUrl("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.updateSecret(secretName, secretVersion, this.apiVersion(), this.acceptLanguage(), parameters, this.userAgent());
        final ServiceCall serviceCall = new ServiceCall(call);
        call.enqueue(new ServiceResponseCallback<SecretBundleInner>(serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    serviceCallback.success(updateSecretDelegate(response));
                } catch (KeyVaultErrorException | IOException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    /**
     * Updates the attributes associated with the specified secret.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param secretName The name of the secret in the given vault
     * @param secretVersion The version of the secret
     * @param contentType Type of the secret value such as a password
     * @param secretAttributes the SecretAttributesInner value
     * @param tags Application-specific metadata in the form of key-value pairs
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the SecretBundleInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<SecretBundleInner> updateSecret(String vaultBaseUrl, String secretName, String secretVersion, String contentType, SecretAttributesInner secretAttributes, Map<String, String> tags) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (secretName == null) {
            throw new IllegalArgumentException("Parameter secretName is required and cannot be null.");
        }
        if (secretVersion == null) {
            throw new IllegalArgumentException("Parameter secretVersion is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        Validator.validate(secretAttributes);
        Validator.validate(tags);
        SecretUpdateParameters parameters = new SecretUpdateParameters();
        parameters.setContentType(contentType);
        parameters.setSecretAttributes(secretAttributes);
        parameters.setTags(tags);
        this.restClient().setBaseUrl("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.updateSecret(secretName, secretVersion, this.apiVersion(), this.acceptLanguage(), parameters, this.userAgent());
        return updateSecretDelegate(call.execute());
    }

    /**
     * Updates the attributes associated with the specified secret.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param secretName The name of the secret in the given vault
     * @param secretVersion The version of the secret
     * @param contentType Type of the secret value such as a password
     * @param secretAttributes the SecretAttributesInner value
     * @param tags Application-specific metadata in the form of key-value pairs
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if callback is null
     * @return the {@link Call} object
     */
    public ServiceCall updateSecretAsync(String vaultBaseUrl, String secretName, String secretVersion, String contentType, SecretAttributesInner secretAttributes, Map<String, String> tags, final ServiceCallback<SecretBundleInner> serviceCallback) throws IllegalArgumentException {
        if (serviceCallback == null) {
            throw new IllegalArgumentException("ServiceCallback is required for async calls.");
        }
        if (vaultBaseUrl == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null."));
            return null;
        }
        if (secretName == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter secretName is required and cannot be null."));
            return null;
        }
        if (secretVersion == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter secretVersion is required and cannot be null."));
            return null;
        }
        if (this.apiVersion() == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null."));
            return null;
        }
        Validator.validate(secretAttributes, serviceCallback);
        Validator.validate(tags, serviceCallback);
        SecretUpdateParameters parameters = new SecretUpdateParameters();
        parameters.setContentType(contentType);
        parameters.setSecretAttributes(secretAttributes);
        parameters.setTags(tags);
        this.restClient().setBaseUrl("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.updateSecret(secretName, secretVersion, this.apiVersion(), this.acceptLanguage(), parameters, this.userAgent());
        final ServiceCall serviceCall = new ServiceCall(call);
        call.enqueue(new ServiceResponseCallback<SecretBundleInner>(serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    serviceCallback.success(updateSecretDelegate(response));
                } catch (KeyVaultErrorException | IOException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<SecretBundleInner> updateSecretDelegate(Response<ResponseBody> response) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<SecretBundleInner, KeyVaultErrorException>(this.restClient().mapperAdapter())
                .register(200, new TypeToken<SecretBundleInner>() { }.getType())
                .registerError(KeyVaultErrorException.class)
                .build(response);
    }

    /**
     * Gets a secret.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param secretName The name of the secret in the given vault
     * @param secretVersion The version of the secret
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the SecretBundleInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<SecretBundleInner> getSecret(String vaultBaseUrl, String secretName, String secretVersion) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (secretName == null) {
            throw new IllegalArgumentException("Parameter secretName is required and cannot be null.");
        }
        if (secretVersion == null) {
            throw new IllegalArgumentException("Parameter secretVersion is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        this.restClient().setBaseUrl("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.getSecret(secretName, secretVersion, this.apiVersion(), this.acceptLanguage(), this.userAgent());
        return getSecretDelegate(call.execute());
    }

    /**
     * Gets a secret.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param secretName The name of the secret in the given vault
     * @param secretVersion The version of the secret
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if callback is null
     * @return the {@link Call} object
     */
    public ServiceCall getSecretAsync(String vaultBaseUrl, String secretName, String secretVersion, final ServiceCallback<SecretBundleInner> serviceCallback) throws IllegalArgumentException {
        if (serviceCallback == null) {
            throw new IllegalArgumentException("ServiceCallback is required for async calls.");
        }
        if (vaultBaseUrl == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null."));
            return null;
        }
        if (secretName == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter secretName is required and cannot be null."));
            return null;
        }
        if (secretVersion == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter secretVersion is required and cannot be null."));
            return null;
        }
        if (this.apiVersion() == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null."));
            return null;
        }
        this.restClient().setBaseUrl("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.getSecret(secretName, secretVersion, this.apiVersion(), this.acceptLanguage(), this.userAgent());
        final ServiceCall serviceCall = new ServiceCall(call);
        call.enqueue(new ServiceResponseCallback<SecretBundleInner>(serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    serviceCallback.success(getSecretDelegate(response));
                } catch (KeyVaultErrorException | IOException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<SecretBundleInner> getSecretDelegate(Response<ResponseBody> response) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<SecretBundleInner, KeyVaultErrorException>(this.restClient().mapperAdapter())
                .register(200, new TypeToken<SecretBundleInner>() { }.getType())
                .registerError(KeyVaultErrorException.class)
                .build(response);
    }

    /**
     * List secrets in the specified vault.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;SecretItemInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PagedList<SecretItemInner>> getSecrets(final String vaultBaseUrl) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        final Integer maxresults = null;
        this.restClient().setBaseUrl("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.getSecrets(maxresults, this.apiVersion(), this.acceptLanguage(), this.userAgent());
        ServiceResponse<PageImpl<SecretItemInner>> response = getSecretsDelegate(call.execute());
        PagedList<SecretItemInner> result = new PagedList<SecretItemInner>(response.getBody()) {
            @Override
            public Page<SecretItemInner> nextPage(String nextPageLink) throws KeyVaultErrorException, IOException {
                return getSecretsNext(nextPageLink).getBody();
            }
        };
        return new ServiceResponse<>(result, response.getResponse());
    }

    /**
     * List secrets in the specified vault.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if callback is null
     * @return the {@link Call} object
     */
    public ServiceCall getSecretsAsync(final String vaultBaseUrl, final ListOperationCallback<SecretItemInner> serviceCallback) throws IllegalArgumentException {
        if (serviceCallback == null) {
            throw new IllegalArgumentException("ServiceCallback is required for async calls.");
        }
        if (vaultBaseUrl == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null."));
            return null;
        }
        if (this.apiVersion() == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null."));
            return null;
        }
        final Integer maxresults = null;
        this.restClient().setBaseUrl("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.getSecrets(maxresults, this.apiVersion(), this.acceptLanguage(), this.userAgent());
        final ServiceCall serviceCall = new ServiceCall(call);
        call.enqueue(new ServiceResponseCallback<List<SecretItemInner>>(serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<PageImpl<SecretItemInner>> result = getSecretsDelegate(response);
                    serviceCallback.load(result.getBody().getItems());
                    if (result.getBody().getNextPageLink() != null
                            && serviceCallback.progress(result.getBody().getItems()) == ListOperationCallback.PagingBahavior.CONTINUE) {
                        getSecretsNextAsync(result.getBody().getNextPageLink(), serviceCall, serviceCallback);
                    } else {
                        serviceCallback.success(new ServiceResponse<>(serviceCallback.get(), result.getResponse()));
                    }
                } catch (KeyVaultErrorException | IOException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    /**
     * List secrets in the specified vault.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param maxresults Maximum number of secrets to return.
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;SecretItemInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PagedList<SecretItemInner>> getSecrets(final String vaultBaseUrl, final Integer maxresults) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        this.restClient().setBaseUrl("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.getSecrets(maxresults, this.apiVersion(), this.acceptLanguage(), this.userAgent());
        ServiceResponse<PageImpl<SecretItemInner>> response = getSecretsDelegate(call.execute());
        PagedList<SecretItemInner> result = new PagedList<SecretItemInner>(response.getBody()) {
            @Override
            public Page<SecretItemInner> nextPage(String nextPageLink) throws KeyVaultErrorException, IOException {
                return getSecretsNext(nextPageLink).getBody();
            }
        };
        return new ServiceResponse<>(result, response.getResponse());
    }

    /**
     * List secrets in the specified vault.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param maxresults Maximum number of secrets to return.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if callback is null
     * @return the {@link Call} object
     */
    public ServiceCall getSecretsAsync(final String vaultBaseUrl, final Integer maxresults, final ListOperationCallback<SecretItemInner> serviceCallback) throws IllegalArgumentException {
        if (serviceCallback == null) {
            throw new IllegalArgumentException("ServiceCallback is required for async calls.");
        }
        if (vaultBaseUrl == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null."));
            return null;
        }
        if (this.apiVersion() == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null."));
            return null;
        }
        this.restClient().setBaseUrl("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.getSecrets(maxresults, this.apiVersion(), this.acceptLanguage(), this.userAgent());
        final ServiceCall serviceCall = new ServiceCall(call);
        call.enqueue(new ServiceResponseCallback<List<SecretItemInner>>(serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<PageImpl<SecretItemInner>> result = getSecretsDelegate(response);
                    serviceCallback.load(result.getBody().getItems());
                    if (result.getBody().getNextPageLink() != null
                            && serviceCallback.progress(result.getBody().getItems()) == ListOperationCallback.PagingBahavior.CONTINUE) {
                        getSecretsNextAsync(result.getBody().getNextPageLink(), serviceCall, serviceCallback);
                    } else {
                        serviceCallback.success(new ServiceResponse<>(serviceCallback.get(), result.getResponse()));
                    }
                } catch (KeyVaultErrorException | IOException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<PageImpl<SecretItemInner>> getSecretsDelegate(Response<ResponseBody> response) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<SecretItemInner>, KeyVaultErrorException>(this.restClient().mapperAdapter())
                .register(200, new TypeToken<PageImpl<SecretItemInner>>() { }.getType())
                .registerError(KeyVaultErrorException.class)
                .build(response);
    }

    /**
     * List the versions of the specified secret.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param secretName The name of the secret in the given vault
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;SecretItemInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PagedList<SecretItemInner>> getSecretVersions(final String vaultBaseUrl, final String secretName) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (secretName == null) {
            throw new IllegalArgumentException("Parameter secretName is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        final Integer maxresults = null;
        this.restClient().setBaseUrl("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.getSecretVersions(secretName, maxresults, this.apiVersion(), this.acceptLanguage(), this.userAgent());
        ServiceResponse<PageImpl<SecretItemInner>> response = getSecretVersionsDelegate(call.execute());
        PagedList<SecretItemInner> result = new PagedList<SecretItemInner>(response.getBody()) {
            @Override
            public Page<SecretItemInner> nextPage(String nextPageLink) throws KeyVaultErrorException, IOException {
                return getSecretVersionsNext(nextPageLink).getBody();
            }
        };
        return new ServiceResponse<>(result, response.getResponse());
    }

    /**
     * List the versions of the specified secret.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param secretName The name of the secret in the given vault
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if callback is null
     * @return the {@link Call} object
     */
    public ServiceCall getSecretVersionsAsync(final String vaultBaseUrl, final String secretName, final ListOperationCallback<SecretItemInner> serviceCallback) throws IllegalArgumentException {
        if (serviceCallback == null) {
            throw new IllegalArgumentException("ServiceCallback is required for async calls.");
        }
        if (vaultBaseUrl == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null."));
            return null;
        }
        if (secretName == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter secretName is required and cannot be null."));
            return null;
        }
        if (this.apiVersion() == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null."));
            return null;
        }
        final Integer maxresults = null;
        this.restClient().setBaseUrl("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.getSecretVersions(secretName, maxresults, this.apiVersion(), this.acceptLanguage(), this.userAgent());
        final ServiceCall serviceCall = new ServiceCall(call);
        call.enqueue(new ServiceResponseCallback<List<SecretItemInner>>(serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<PageImpl<SecretItemInner>> result = getSecretVersionsDelegate(response);
                    serviceCallback.load(result.getBody().getItems());
                    if (result.getBody().getNextPageLink() != null
                            && serviceCallback.progress(result.getBody().getItems()) == ListOperationCallback.PagingBahavior.CONTINUE) {
                        getSecretVersionsNextAsync(result.getBody().getNextPageLink(), serviceCall, serviceCallback);
                    } else {
                        serviceCallback.success(new ServiceResponse<>(serviceCallback.get(), result.getResponse()));
                    }
                } catch (KeyVaultErrorException | IOException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    /**
     * List the versions of the specified secret.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param secretName The name of the secret in the given vault
     * @param maxresults Maximum number of results to return.
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;SecretItemInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PagedList<SecretItemInner>> getSecretVersions(final String vaultBaseUrl, final String secretName, final Integer maxresults) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (secretName == null) {
            throw new IllegalArgumentException("Parameter secretName is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        this.restClient().setBaseUrl("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.getSecretVersions(secretName, maxresults, this.apiVersion(), this.acceptLanguage(), this.userAgent());
        ServiceResponse<PageImpl<SecretItemInner>> response = getSecretVersionsDelegate(call.execute());
        PagedList<SecretItemInner> result = new PagedList<SecretItemInner>(response.getBody()) {
            @Override
            public Page<SecretItemInner> nextPage(String nextPageLink) throws KeyVaultErrorException, IOException {
                return getSecretVersionsNext(nextPageLink).getBody();
            }
        };
        return new ServiceResponse<>(result, response.getResponse());
    }

    /**
     * List the versions of the specified secret.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param secretName The name of the secret in the given vault
     * @param maxresults Maximum number of results to return.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if callback is null
     * @return the {@link Call} object
     */
    public ServiceCall getSecretVersionsAsync(final String vaultBaseUrl, final String secretName, final Integer maxresults, final ListOperationCallback<SecretItemInner> serviceCallback) throws IllegalArgumentException {
        if (serviceCallback == null) {
            throw new IllegalArgumentException("ServiceCallback is required for async calls.");
        }
        if (vaultBaseUrl == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null."));
            return null;
        }
        if (secretName == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter secretName is required and cannot be null."));
            return null;
        }
        if (this.apiVersion() == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null."));
            return null;
        }
        this.restClient().setBaseUrl("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.getSecretVersions(secretName, maxresults, this.apiVersion(), this.acceptLanguage(), this.userAgent());
        final ServiceCall serviceCall = new ServiceCall(call);
        call.enqueue(new ServiceResponseCallback<List<SecretItemInner>>(serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<PageImpl<SecretItemInner>> result = getSecretVersionsDelegate(response);
                    serviceCallback.load(result.getBody().getItems());
                    if (result.getBody().getNextPageLink() != null
                            && serviceCallback.progress(result.getBody().getItems()) == ListOperationCallback.PagingBahavior.CONTINUE) {
                        getSecretVersionsNextAsync(result.getBody().getNextPageLink(), serviceCall, serviceCallback);
                    } else {
                        serviceCallback.success(new ServiceResponse<>(serviceCallback.get(), result.getResponse()));
                    }
                } catch (KeyVaultErrorException | IOException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<PageImpl<SecretItemInner>> getSecretVersionsDelegate(Response<ResponseBody> response) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<SecretItemInner>, KeyVaultErrorException>(this.restClient().mapperAdapter())
                .register(200, new TypeToken<PageImpl<SecretItemInner>>() { }.getType())
                .registerError(KeyVaultErrorException.class)
                .build(response);
    }

    /**
     * List certificates in the specified vault.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;CertificateItemInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PagedList<CertificateItemInner>> getCertificates(final String vaultBaseUrl) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        final Integer maxresults = null;
        this.restClient().setBaseUrl("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.getCertificates(maxresults, this.apiVersion(), this.acceptLanguage(), this.userAgent());
        ServiceResponse<PageImpl<CertificateItemInner>> response = getCertificatesDelegate(call.execute());
        PagedList<CertificateItemInner> result = new PagedList<CertificateItemInner>(response.getBody()) {
            @Override
            public Page<CertificateItemInner> nextPage(String nextPageLink) throws KeyVaultErrorException, IOException {
                return getCertificatesNext(nextPageLink).getBody();
            }
        };
        return new ServiceResponse<>(result, response.getResponse());
    }

    /**
     * List certificates in the specified vault.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if callback is null
     * @return the {@link Call} object
     */
    public ServiceCall getCertificatesAsync(final String vaultBaseUrl, final ListOperationCallback<CertificateItemInner> serviceCallback) throws IllegalArgumentException {
        if (serviceCallback == null) {
            throw new IllegalArgumentException("ServiceCallback is required for async calls.");
        }
        if (vaultBaseUrl == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null."));
            return null;
        }
        if (this.apiVersion() == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null."));
            return null;
        }
        final Integer maxresults = null;
        this.restClient().setBaseUrl("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.getCertificates(maxresults, this.apiVersion(), this.acceptLanguage(), this.userAgent());
        final ServiceCall serviceCall = new ServiceCall(call);
        call.enqueue(new ServiceResponseCallback<List<CertificateItemInner>>(serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<PageImpl<CertificateItemInner>> result = getCertificatesDelegate(response);
                    serviceCallback.load(result.getBody().getItems());
                    if (result.getBody().getNextPageLink() != null
                            && serviceCallback.progress(result.getBody().getItems()) == ListOperationCallback.PagingBahavior.CONTINUE) {
                        getCertificatesNextAsync(result.getBody().getNextPageLink(), serviceCall, serviceCallback);
                    } else {
                        serviceCallback.success(new ServiceResponse<>(serviceCallback.get(), result.getResponse()));
                    }
                } catch (KeyVaultErrorException | IOException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    /**
     * List certificates in the specified vault.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param maxresults Maximum number of results to return.
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;CertificateItemInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PagedList<CertificateItemInner>> getCertificates(final String vaultBaseUrl, final Integer maxresults) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        this.restClient().setBaseUrl("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.getCertificates(maxresults, this.apiVersion(), this.acceptLanguage(), this.userAgent());
        ServiceResponse<PageImpl<CertificateItemInner>> response = getCertificatesDelegate(call.execute());
        PagedList<CertificateItemInner> result = new PagedList<CertificateItemInner>(response.getBody()) {
            @Override
            public Page<CertificateItemInner> nextPage(String nextPageLink) throws KeyVaultErrorException, IOException {
                return getCertificatesNext(nextPageLink).getBody();
            }
        };
        return new ServiceResponse<>(result, response.getResponse());
    }

    /**
     * List certificates in the specified vault.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param maxresults Maximum number of results to return.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if callback is null
     * @return the {@link Call} object
     */
    public ServiceCall getCertificatesAsync(final String vaultBaseUrl, final Integer maxresults, final ListOperationCallback<CertificateItemInner> serviceCallback) throws IllegalArgumentException {
        if (serviceCallback == null) {
            throw new IllegalArgumentException("ServiceCallback is required for async calls.");
        }
        if (vaultBaseUrl == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null."));
            return null;
        }
        if (this.apiVersion() == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null."));
            return null;
        }
        this.restClient().setBaseUrl("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.getCertificates(maxresults, this.apiVersion(), this.acceptLanguage(), this.userAgent());
        final ServiceCall serviceCall = new ServiceCall(call);
        call.enqueue(new ServiceResponseCallback<List<CertificateItemInner>>(serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<PageImpl<CertificateItemInner>> result = getCertificatesDelegate(response);
                    serviceCallback.load(result.getBody().getItems());
                    if (result.getBody().getNextPageLink() != null
                            && serviceCallback.progress(result.getBody().getItems()) == ListOperationCallback.PagingBahavior.CONTINUE) {
                        getCertificatesNextAsync(result.getBody().getNextPageLink(), serviceCall, serviceCallback);
                    } else {
                        serviceCallback.success(new ServiceResponse<>(serviceCallback.get(), result.getResponse()));
                    }
                } catch (KeyVaultErrorException | IOException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<PageImpl<CertificateItemInner>> getCertificatesDelegate(Response<ResponseBody> response) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<CertificateItemInner>, KeyVaultErrorException>(this.restClient().mapperAdapter())
                .register(200, new TypeToken<PageImpl<CertificateItemInner>>() { }.getType())
                .registerError(KeyVaultErrorException.class)
                .build(response);
    }

    /**
     * Deletes a certificate from the specified vault.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param certificateName The name of the certificate in the given vault
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the CertificateBundleInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<CertificateBundleInner> deleteCertificate(String vaultBaseUrl, String certificateName) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (certificateName == null) {
            throw new IllegalArgumentException("Parameter certificateName is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        this.restClient().setBaseUrl("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.deleteCertificate(certificateName, this.apiVersion(), this.acceptLanguage(), this.userAgent());
        return deleteCertificateDelegate(call.execute());
    }

    /**
     * Deletes a certificate from the specified vault.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param certificateName The name of the certificate in the given vault
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if callback is null
     * @return the {@link Call} object
     */
    public ServiceCall deleteCertificateAsync(String vaultBaseUrl, String certificateName, final ServiceCallback<CertificateBundleInner> serviceCallback) throws IllegalArgumentException {
        if (serviceCallback == null) {
            throw new IllegalArgumentException("ServiceCallback is required for async calls.");
        }
        if (vaultBaseUrl == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null."));
            return null;
        }
        if (certificateName == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter certificateName is required and cannot be null."));
            return null;
        }
        if (this.apiVersion() == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null."));
            return null;
        }
        this.restClient().setBaseUrl("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.deleteCertificate(certificateName, this.apiVersion(), this.acceptLanguage(), this.userAgent());
        final ServiceCall serviceCall = new ServiceCall(call);
        call.enqueue(new ServiceResponseCallback<CertificateBundleInner>(serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    serviceCallback.success(deleteCertificateDelegate(response));
                } catch (KeyVaultErrorException | IOException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<CertificateBundleInner> deleteCertificateDelegate(Response<ResponseBody> response) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<CertificateBundleInner, KeyVaultErrorException>(this.restClient().mapperAdapter())
                .register(200, new TypeToken<CertificateBundleInner>() { }.getType())
                .registerError(KeyVaultErrorException.class)
                .build(response);
    }

    /**
     * Sets the certificate contacts for the specified vault.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param contacts Contacts.
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the ContactsInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<ContactsInner> setCertificateContacts(String vaultBaseUrl, ContactsInner contacts) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (contacts == null) {
            throw new IllegalArgumentException("Parameter contacts is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        Validator.validate(contacts);
        this.restClient().setBaseUrl("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.setCertificateContacts(contacts, this.apiVersion(), this.acceptLanguage(), this.userAgent());
        return setCertificateContactsDelegate(call.execute());
    }

    /**
     * Sets the certificate contacts for the specified vault.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param contacts Contacts.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if callback is null
     * @return the {@link Call} object
     */
    public ServiceCall setCertificateContactsAsync(String vaultBaseUrl, ContactsInner contacts, final ServiceCallback<ContactsInner> serviceCallback) throws IllegalArgumentException {
        if (serviceCallback == null) {
            throw new IllegalArgumentException("ServiceCallback is required for async calls.");
        }
        if (vaultBaseUrl == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null."));
            return null;
        }
        if (contacts == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter contacts is required and cannot be null."));
            return null;
        }
        if (this.apiVersion() == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null."));
            return null;
        }
        Validator.validate(contacts, serviceCallback);
        this.restClient().setBaseUrl("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.setCertificateContacts(contacts, this.apiVersion(), this.acceptLanguage(), this.userAgent());
        final ServiceCall serviceCall = new ServiceCall(call);
        call.enqueue(new ServiceResponseCallback<ContactsInner>(serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    serviceCallback.success(setCertificateContactsDelegate(response));
                } catch (KeyVaultErrorException | IOException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<ContactsInner> setCertificateContactsDelegate(Response<ResponseBody> response) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<ContactsInner, KeyVaultErrorException>(this.restClient().mapperAdapter())
                .register(200, new TypeToken<ContactsInner>() { }.getType())
                .registerError(KeyVaultErrorException.class)
                .build(response);
    }

    /**
     * Gets the certificate contacts for the specified vault.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the ContactsInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<ContactsInner> getCertificateContacts(String vaultBaseUrl) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        this.restClient().setBaseUrl("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.getCertificateContacts(this.apiVersion(), this.acceptLanguage(), this.userAgent());
        return getCertificateContactsDelegate(call.execute());
    }

    /**
     * Gets the certificate contacts for the specified vault.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if callback is null
     * @return the {@link Call} object
     */
    public ServiceCall getCertificateContactsAsync(String vaultBaseUrl, final ServiceCallback<ContactsInner> serviceCallback) throws IllegalArgumentException {
        if (serviceCallback == null) {
            throw new IllegalArgumentException("ServiceCallback is required for async calls.");
        }
        if (vaultBaseUrl == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null."));
            return null;
        }
        if (this.apiVersion() == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null."));
            return null;
        }
        this.restClient().setBaseUrl("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.getCertificateContacts(this.apiVersion(), this.acceptLanguage(), this.userAgent());
        final ServiceCall serviceCall = new ServiceCall(call);
        call.enqueue(new ServiceResponseCallback<ContactsInner>(serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    serviceCallback.success(getCertificateContactsDelegate(response));
                } catch (KeyVaultErrorException | IOException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<ContactsInner> getCertificateContactsDelegate(Response<ResponseBody> response) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<ContactsInner, KeyVaultErrorException>(this.restClient().mapperAdapter())
                .register(200, new TypeToken<ContactsInner>() { }.getType())
                .registerError(KeyVaultErrorException.class)
                .build(response);
    }

    /**
     * Deletes the certificate contacts for the specified vault.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the ContactsInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<ContactsInner> deleteCertificateContacts(String vaultBaseUrl) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        this.restClient().setBaseUrl("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.deleteCertificateContacts(this.apiVersion(), this.acceptLanguage(), this.userAgent());
        return deleteCertificateContactsDelegate(call.execute());
    }

    /**
     * Deletes the certificate contacts for the specified vault.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if callback is null
     * @return the {@link Call} object
     */
    public ServiceCall deleteCertificateContactsAsync(String vaultBaseUrl, final ServiceCallback<ContactsInner> serviceCallback) throws IllegalArgumentException {
        if (serviceCallback == null) {
            throw new IllegalArgumentException("ServiceCallback is required for async calls.");
        }
        if (vaultBaseUrl == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null."));
            return null;
        }
        if (this.apiVersion() == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null."));
            return null;
        }
        this.restClient().setBaseUrl("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.deleteCertificateContacts(this.apiVersion(), this.acceptLanguage(), this.userAgent());
        final ServiceCall serviceCall = new ServiceCall(call);
        call.enqueue(new ServiceResponseCallback<ContactsInner>(serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    serviceCallback.success(deleteCertificateContactsDelegate(response));
                } catch (KeyVaultErrorException | IOException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<ContactsInner> deleteCertificateContactsDelegate(Response<ResponseBody> response) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<ContactsInner, KeyVaultErrorException>(this.restClient().mapperAdapter())
                .register(200, new TypeToken<ContactsInner>() { }.getType())
                .registerError(KeyVaultErrorException.class)
                .build(response);
    }

    /**
     * List certificate issuers for the specified vault.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;CertificateIssuerItemInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PagedList<CertificateIssuerItemInner>> getCertificateIssuers(final String vaultBaseUrl) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        final Integer maxresults = null;
        this.restClient().setBaseUrl("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.getCertificateIssuers(maxresults, this.apiVersion(), this.acceptLanguage(), this.userAgent());
        ServiceResponse<PageImpl<CertificateIssuerItemInner>> response = getCertificateIssuersDelegate(call.execute());
        PagedList<CertificateIssuerItemInner> result = new PagedList<CertificateIssuerItemInner>(response.getBody()) {
            @Override
            public Page<CertificateIssuerItemInner> nextPage(String nextPageLink) throws KeyVaultErrorException, IOException {
                return getCertificateIssuersNext(nextPageLink).getBody();
            }
        };
        return new ServiceResponse<>(result, response.getResponse());
    }

    /**
     * List certificate issuers for the specified vault.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if callback is null
     * @return the {@link Call} object
     */
    public ServiceCall getCertificateIssuersAsync(final String vaultBaseUrl, final ListOperationCallback<CertificateIssuerItemInner> serviceCallback) throws IllegalArgumentException {
        if (serviceCallback == null) {
            throw new IllegalArgumentException("ServiceCallback is required for async calls.");
        }
        if (vaultBaseUrl == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null."));
            return null;
        }
        if (this.apiVersion() == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null."));
            return null;
        }
        final Integer maxresults = null;
        this.restClient().setBaseUrl("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.getCertificateIssuers(maxresults, this.apiVersion(), this.acceptLanguage(), this.userAgent());
        final ServiceCall serviceCall = new ServiceCall(call);
        call.enqueue(new ServiceResponseCallback<List<CertificateIssuerItemInner>>(serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<PageImpl<CertificateIssuerItemInner>> result = getCertificateIssuersDelegate(response);
                    serviceCallback.load(result.getBody().getItems());
                    if (result.getBody().getNextPageLink() != null
                            && serviceCallback.progress(result.getBody().getItems()) == ListOperationCallback.PagingBahavior.CONTINUE) {
                        getCertificateIssuersNextAsync(result.getBody().getNextPageLink(), serviceCall, serviceCallback);
                    } else {
                        serviceCallback.success(new ServiceResponse<>(serviceCallback.get(), result.getResponse()));
                    }
                } catch (KeyVaultErrorException | IOException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    /**
     * List certificate issuers for the specified vault.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param maxresults Maximum number of results to return.
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;CertificateIssuerItemInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PagedList<CertificateIssuerItemInner>> getCertificateIssuers(final String vaultBaseUrl, final Integer maxresults) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        this.restClient().setBaseUrl("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.getCertificateIssuers(maxresults, this.apiVersion(), this.acceptLanguage(), this.userAgent());
        ServiceResponse<PageImpl<CertificateIssuerItemInner>> response = getCertificateIssuersDelegate(call.execute());
        PagedList<CertificateIssuerItemInner> result = new PagedList<CertificateIssuerItemInner>(response.getBody()) {
            @Override
            public Page<CertificateIssuerItemInner> nextPage(String nextPageLink) throws KeyVaultErrorException, IOException {
                return getCertificateIssuersNext(nextPageLink).getBody();
            }
        };
        return new ServiceResponse<>(result, response.getResponse());
    }

    /**
     * List certificate issuers for the specified vault.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param maxresults Maximum number of results to return.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if callback is null
     * @return the {@link Call} object
     */
    public ServiceCall getCertificateIssuersAsync(final String vaultBaseUrl, final Integer maxresults, final ListOperationCallback<CertificateIssuerItemInner> serviceCallback) throws IllegalArgumentException {
        if (serviceCallback == null) {
            throw new IllegalArgumentException("ServiceCallback is required for async calls.");
        }
        if (vaultBaseUrl == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null."));
            return null;
        }
        if (this.apiVersion() == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null."));
            return null;
        }
        this.restClient().setBaseUrl("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.getCertificateIssuers(maxresults, this.apiVersion(), this.acceptLanguage(), this.userAgent());
        final ServiceCall serviceCall = new ServiceCall(call);
        call.enqueue(new ServiceResponseCallback<List<CertificateIssuerItemInner>>(serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<PageImpl<CertificateIssuerItemInner>> result = getCertificateIssuersDelegate(response);
                    serviceCallback.load(result.getBody().getItems());
                    if (result.getBody().getNextPageLink() != null
                            && serviceCallback.progress(result.getBody().getItems()) == ListOperationCallback.PagingBahavior.CONTINUE) {
                        getCertificateIssuersNextAsync(result.getBody().getNextPageLink(), serviceCall, serviceCallback);
                    } else {
                        serviceCallback.success(new ServiceResponse<>(serviceCallback.get(), result.getResponse()));
                    }
                } catch (KeyVaultErrorException | IOException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<PageImpl<CertificateIssuerItemInner>> getCertificateIssuersDelegate(Response<ResponseBody> response) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<CertificateIssuerItemInner>, KeyVaultErrorException>(this.restClient().mapperAdapter())
                .register(200, new TypeToken<PageImpl<CertificateIssuerItemInner>>() { }.getType())
                .registerError(KeyVaultErrorException.class)
                .build(response);
    }

    /**
     * Sets the certificate contacts for the specified vault.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param issuerName The name of the issuer.
     * @param issuer The issuer bundle.
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the IssuerBundleInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<IssuerBundleInner> setCertificateIssuer(String vaultBaseUrl, String issuerName, IssuerBundleInner issuer) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (issuerName == null) {
            throw new IllegalArgumentException("Parameter issuerName is required and cannot be null.");
        }
        if (issuer == null) {
            throw new IllegalArgumentException("Parameter issuer is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        Validator.validate(issuer);
        this.restClient().setBaseUrl("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.setCertificateIssuer(issuerName, issuer, this.apiVersion(), this.acceptLanguage(), this.userAgent());
        return setCertificateIssuerDelegate(call.execute());
    }

    /**
     * Sets the certificate contacts for the specified vault.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param issuerName The name of the issuer.
     * @param issuer The issuer bundle.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if callback is null
     * @return the {@link Call} object
     */
    public ServiceCall setCertificateIssuerAsync(String vaultBaseUrl, String issuerName, IssuerBundleInner issuer, final ServiceCallback<IssuerBundleInner> serviceCallback) throws IllegalArgumentException {
        if (serviceCallback == null) {
            throw new IllegalArgumentException("ServiceCallback is required for async calls.");
        }
        if (vaultBaseUrl == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null."));
            return null;
        }
        if (issuerName == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter issuerName is required and cannot be null."));
            return null;
        }
        if (issuer == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter issuer is required and cannot be null."));
            return null;
        }
        if (this.apiVersion() == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null."));
            return null;
        }
        Validator.validate(issuer, serviceCallback);
        this.restClient().setBaseUrl("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.setCertificateIssuer(issuerName, issuer, this.apiVersion(), this.acceptLanguage(), this.userAgent());
        final ServiceCall serviceCall = new ServiceCall(call);
        call.enqueue(new ServiceResponseCallback<IssuerBundleInner>(serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    serviceCallback.success(setCertificateIssuerDelegate(response));
                } catch (KeyVaultErrorException | IOException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<IssuerBundleInner> setCertificateIssuerDelegate(Response<ResponseBody> response) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<IssuerBundleInner, KeyVaultErrorException>(this.restClient().mapperAdapter())
                .register(200, new TypeToken<IssuerBundleInner>() { }.getType())
                .registerError(KeyVaultErrorException.class)
                .build(response);
    }

    /**
     * Updates the specified certificate issuer.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param issuerName The name of the issuer.
     * @param issuer The issuer bundle.
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the IssuerBundleInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<IssuerBundleInner> updateCertificateIssuer(String vaultBaseUrl, String issuerName, IssuerBundleInner issuer) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (issuerName == null) {
            throw new IllegalArgumentException("Parameter issuerName is required and cannot be null.");
        }
        if (issuer == null) {
            throw new IllegalArgumentException("Parameter issuer is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        Validator.validate(issuer);
        this.restClient().setBaseUrl("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.updateCertificateIssuer(issuerName, issuer, this.apiVersion(), this.acceptLanguage(), this.userAgent());
        return updateCertificateIssuerDelegate(call.execute());
    }

    /**
     * Updates the specified certificate issuer.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param issuerName The name of the issuer.
     * @param issuer The issuer bundle.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if callback is null
     * @return the {@link Call} object
     */
    public ServiceCall updateCertificateIssuerAsync(String vaultBaseUrl, String issuerName, IssuerBundleInner issuer, final ServiceCallback<IssuerBundleInner> serviceCallback) throws IllegalArgumentException {
        if (serviceCallback == null) {
            throw new IllegalArgumentException("ServiceCallback is required for async calls.");
        }
        if (vaultBaseUrl == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null."));
            return null;
        }
        if (issuerName == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter issuerName is required and cannot be null."));
            return null;
        }
        if (issuer == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter issuer is required and cannot be null."));
            return null;
        }
        if (this.apiVersion() == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null."));
            return null;
        }
        Validator.validate(issuer, serviceCallback);
        this.restClient().setBaseUrl("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.updateCertificateIssuer(issuerName, issuer, this.apiVersion(), this.acceptLanguage(), this.userAgent());
        final ServiceCall serviceCall = new ServiceCall(call);
        call.enqueue(new ServiceResponseCallback<IssuerBundleInner>(serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    serviceCallback.success(updateCertificateIssuerDelegate(response));
                } catch (KeyVaultErrorException | IOException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<IssuerBundleInner> updateCertificateIssuerDelegate(Response<ResponseBody> response) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<IssuerBundleInner, KeyVaultErrorException>(this.restClient().mapperAdapter())
                .register(200, new TypeToken<IssuerBundleInner>() { }.getType())
                .registerError(KeyVaultErrorException.class)
                .build(response);
    }

    /**
     * Gets the specified certificate issuer.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param issuerName The name of the issuer.
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the IssuerBundleInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<IssuerBundleInner> getCertificateIssuer(String vaultBaseUrl, String issuerName) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (issuerName == null) {
            throw new IllegalArgumentException("Parameter issuerName is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        this.restClient().setBaseUrl("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.getCertificateIssuer(issuerName, this.apiVersion(), this.acceptLanguage(), this.userAgent());
        return getCertificateIssuerDelegate(call.execute());
    }

    /**
     * Gets the specified certificate issuer.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param issuerName The name of the issuer.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if callback is null
     * @return the {@link Call} object
     */
    public ServiceCall getCertificateIssuerAsync(String vaultBaseUrl, String issuerName, final ServiceCallback<IssuerBundleInner> serviceCallback) throws IllegalArgumentException {
        if (serviceCallback == null) {
            throw new IllegalArgumentException("ServiceCallback is required for async calls.");
        }
        if (vaultBaseUrl == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null."));
            return null;
        }
        if (issuerName == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter issuerName is required and cannot be null."));
            return null;
        }
        if (this.apiVersion() == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null."));
            return null;
        }
        this.restClient().setBaseUrl("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.getCertificateIssuer(issuerName, this.apiVersion(), this.acceptLanguage(), this.userAgent());
        final ServiceCall serviceCall = new ServiceCall(call);
        call.enqueue(new ServiceResponseCallback<IssuerBundleInner>(serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    serviceCallback.success(getCertificateIssuerDelegate(response));
                } catch (KeyVaultErrorException | IOException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<IssuerBundleInner> getCertificateIssuerDelegate(Response<ResponseBody> response) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<IssuerBundleInner, KeyVaultErrorException>(this.restClient().mapperAdapter())
                .register(200, new TypeToken<IssuerBundleInner>() { }.getType())
                .registerError(KeyVaultErrorException.class)
                .build(response);
    }

    /**
     * Deletes the specified certificate issuer.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param issuerName The name of the issuer.
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the IssuerBundleInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<IssuerBundleInner> deleteCertificateIssuer(String vaultBaseUrl, String issuerName) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (issuerName == null) {
            throw new IllegalArgumentException("Parameter issuerName is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        this.restClient().setBaseUrl("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.deleteCertificateIssuer(issuerName, this.apiVersion(), this.acceptLanguage(), this.userAgent());
        return deleteCertificateIssuerDelegate(call.execute());
    }

    /**
     * Deletes the specified certificate issuer.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param issuerName The name of the issuer.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if callback is null
     * @return the {@link Call} object
     */
    public ServiceCall deleteCertificateIssuerAsync(String vaultBaseUrl, String issuerName, final ServiceCallback<IssuerBundleInner> serviceCallback) throws IllegalArgumentException {
        if (serviceCallback == null) {
            throw new IllegalArgumentException("ServiceCallback is required for async calls.");
        }
        if (vaultBaseUrl == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null."));
            return null;
        }
        if (issuerName == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter issuerName is required and cannot be null."));
            return null;
        }
        if (this.apiVersion() == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null."));
            return null;
        }
        this.restClient().setBaseUrl("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.deleteCertificateIssuer(issuerName, this.apiVersion(), this.acceptLanguage(), this.userAgent());
        final ServiceCall serviceCall = new ServiceCall(call);
        call.enqueue(new ServiceResponseCallback<IssuerBundleInner>(serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    serviceCallback.success(deleteCertificateIssuerDelegate(response));
                } catch (KeyVaultErrorException | IOException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<IssuerBundleInner> deleteCertificateIssuerDelegate(Response<ResponseBody> response) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<IssuerBundleInner, KeyVaultErrorException>(this.restClient().mapperAdapter())
                .register(200, new TypeToken<IssuerBundleInner>() { }.getType())
                .registerError(KeyVaultErrorException.class)
                .build(response);
    }

    /**
     * Creates a new certificate version. If this is the first version, the certificate resource is created.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param certificateName The name of the certificate
     * @param certificatePolicy The management policy for the certificate
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the CertificateOperationInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<CertificateOperationInner> createCertificate(String vaultBaseUrl, String certificateName, CertificatePolicyInner certificatePolicy) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (certificateName == null) {
            throw new IllegalArgumentException("Parameter certificateName is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        if (certificatePolicy == null) {
            throw new IllegalArgumentException("Parameter certificatePolicy is required and cannot be null.");
        }
        Validator.validate(certificatePolicy);
        final CertificateAttributesInner certificateAttributes = null;
        final Map<String, String> tags = null;
        CertificateCreateParameters parameters = new CertificateCreateParameters();
        parameters.setCertificatePolicy(certificatePolicy);
        parameters.setCertificateAttributes(null);
        parameters.setTags(null);
        this.restClient().setBaseUrl("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.createCertificate(certificateName, this.apiVersion(), this.acceptLanguage(), parameters, this.userAgent());
        return createCertificateDelegate(call.execute());
    }

    /**
     * Creates a new certificate version. If this is the first version, the certificate resource is created.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param certificateName The name of the certificate
     * @param certificatePolicy The management policy for the certificate
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if callback is null
     * @return the {@link Call} object
     */
    public ServiceCall createCertificateAsync(String vaultBaseUrl, String certificateName, CertificatePolicyInner certificatePolicy, final ServiceCallback<CertificateOperationInner> serviceCallback) throws IllegalArgumentException {
        if (serviceCallback == null) {
            throw new IllegalArgumentException("ServiceCallback is required for async calls.");
        }
        if (vaultBaseUrl == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null."));
            return null;
        }
        if (certificateName == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter certificateName is required and cannot be null."));
            return null;
        }
        if (this.apiVersion() == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null."));
            return null;
        }
        if (certificatePolicy == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter certificatePolicy is required and cannot be null."));
            return null;
        }
        Validator.validate(certificatePolicy, serviceCallback);
        final CertificateAttributesInner certificateAttributes = null;
        final Map<String, String> tags = null;
        CertificateCreateParameters parameters = new CertificateCreateParameters();
        parameters.setCertificatePolicy(certificatePolicy);
        parameters.setCertificateAttributes(null);
        parameters.setTags(null);
        this.restClient().setBaseUrl("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.createCertificate(certificateName, this.apiVersion(), this.acceptLanguage(), parameters, this.userAgent());
        final ServiceCall serviceCall = new ServiceCall(call);
        call.enqueue(new ServiceResponseCallback<CertificateOperationInner>(serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    serviceCallback.success(createCertificateDelegate(response));
                } catch (KeyVaultErrorException | IOException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    /**
     * Creates a new certificate version. If this is the first version, the certificate resource is created.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param certificateName The name of the certificate
     * @param certificatePolicy The management policy for the certificate
     * @param certificateAttributes The attributes of the certificate (optional)
     * @param tags Application-specific metadata in the form of key-value pairs
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the CertificateOperationInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<CertificateOperationInner> createCertificate(String vaultBaseUrl, String certificateName, CertificatePolicyInner certificatePolicy, CertificateAttributesInner certificateAttributes, Map<String, String> tags) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (certificateName == null) {
            throw new IllegalArgumentException("Parameter certificateName is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        if (certificatePolicy == null) {
            throw new IllegalArgumentException("Parameter certificatePolicy is required and cannot be null.");
        }
        Validator.validate(certificatePolicy);
        Validator.validate(certificateAttributes);
        Validator.validate(tags);
        CertificateCreateParameters parameters = new CertificateCreateParameters();
        parameters.setCertificatePolicy(certificatePolicy);
        parameters.setCertificateAttributes(certificateAttributes);
        parameters.setTags(tags);
        this.restClient().setBaseUrl("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.createCertificate(certificateName, this.apiVersion(), this.acceptLanguage(), parameters, this.userAgent());
        return createCertificateDelegate(call.execute());
    }

    /**
     * Creates a new certificate version. If this is the first version, the certificate resource is created.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param certificateName The name of the certificate
     * @param certificatePolicy The management policy for the certificate
     * @param certificateAttributes The attributes of the certificate (optional)
     * @param tags Application-specific metadata in the form of key-value pairs
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if callback is null
     * @return the {@link Call} object
     */
    public ServiceCall createCertificateAsync(String vaultBaseUrl, String certificateName, CertificatePolicyInner certificatePolicy, CertificateAttributesInner certificateAttributes, Map<String, String> tags, final ServiceCallback<CertificateOperationInner> serviceCallback) throws IllegalArgumentException {
        if (serviceCallback == null) {
            throw new IllegalArgumentException("ServiceCallback is required for async calls.");
        }
        if (vaultBaseUrl == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null."));
            return null;
        }
        if (certificateName == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter certificateName is required and cannot be null."));
            return null;
        }
        if (this.apiVersion() == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null."));
            return null;
        }
        if (certificatePolicy == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter certificatePolicy is required and cannot be null."));
            return null;
        }
        Validator.validate(certificatePolicy, serviceCallback);
        Validator.validate(certificateAttributes, serviceCallback);
        Validator.validate(tags, serviceCallback);
        CertificateCreateParameters parameters = new CertificateCreateParameters();
        parameters.setCertificatePolicy(certificatePolicy);
        parameters.setCertificateAttributes(certificateAttributes);
        parameters.setTags(tags);
        this.restClient().setBaseUrl("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.createCertificate(certificateName, this.apiVersion(), this.acceptLanguage(), parameters, this.userAgent());
        final ServiceCall serviceCall = new ServiceCall(call);
        call.enqueue(new ServiceResponseCallback<CertificateOperationInner>(serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    serviceCallback.success(createCertificateDelegate(response));
                } catch (KeyVaultErrorException | IOException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<CertificateOperationInner> createCertificateDelegate(Response<ResponseBody> response) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<CertificateOperationInner, KeyVaultErrorException>(this.restClient().mapperAdapter())
                .register(202, new TypeToken<CertificateOperationInner>() { }.getType())
                .registerError(KeyVaultErrorException.class)
                .build(response);
    }

    /**
     * Imports a certificate into the specified vault.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param certificateName The name of the certificate
     * @param base64EncodedCertificate Base64 encoded representaion of the certificate object to import. This certificate needs to contain the private key.
     * @param password If the private key in base64EncodedCertificate is encrypted, the password used for encryption
     * @param certificatePolicy The management policy for the certificate
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the CertificateBundleInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<CertificateBundleInner> importCertificate(String vaultBaseUrl, String certificateName, String base64EncodedCertificate, String password, CertificatePolicyInner certificatePolicy) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (certificateName == null) {
            throw new IllegalArgumentException("Parameter certificateName is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        if (base64EncodedCertificate == null) {
            throw new IllegalArgumentException("Parameter base64EncodedCertificate is required and cannot be null.");
        }
        if (password == null) {
            throw new IllegalArgumentException("Parameter password is required and cannot be null.");
        }
        if (certificatePolicy == null) {
            throw new IllegalArgumentException("Parameter certificatePolicy is required and cannot be null.");
        }
        Validator.validate(certificatePolicy);
        final CertificateAttributesInner certificateAttributes = null;
        final Map<String, String> tags = null;
        CertificateImportParameters parameters = new CertificateImportParameters();
        parameters.setBase64EncodedCertificate(base64EncodedCertificate);
        parameters.setPassword(password);
        parameters.setCertificatePolicy(certificatePolicy);
        parameters.setCertificateAttributes(null);
        parameters.setTags(null);
        this.restClient().setBaseUrl("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.importCertificate(certificateName, this.apiVersion(), this.acceptLanguage(), parameters, this.userAgent());
        return importCertificateDelegate(call.execute());
    }

    /**
     * Imports a certificate into the specified vault.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param certificateName The name of the certificate
     * @param base64EncodedCertificate Base64 encoded representaion of the certificate object to import. This certificate needs to contain the private key.
     * @param password If the private key in base64EncodedCertificate is encrypted, the password used for encryption
     * @param certificatePolicy The management policy for the certificate
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if callback is null
     * @return the {@link Call} object
     */
    public ServiceCall importCertificateAsync(String vaultBaseUrl, String certificateName, String base64EncodedCertificate, String password, CertificatePolicyInner certificatePolicy, final ServiceCallback<CertificateBundleInner> serviceCallback) throws IllegalArgumentException {
        if (serviceCallback == null) {
            throw new IllegalArgumentException("ServiceCallback is required for async calls.");
        }
        if (vaultBaseUrl == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null."));
            return null;
        }
        if (certificateName == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter certificateName is required and cannot be null."));
            return null;
        }
        if (this.apiVersion() == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null."));
            return null;
        }
        if (base64EncodedCertificate == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter base64EncodedCertificate is required and cannot be null."));
            return null;
        }
        if (password == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter password is required and cannot be null."));
            return null;
        }
        if (certificatePolicy == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter certificatePolicy is required and cannot be null."));
            return null;
        }
        Validator.validate(certificatePolicy, serviceCallback);
        final CertificateAttributesInner certificateAttributes = null;
        final Map<String, String> tags = null;
        CertificateImportParameters parameters = new CertificateImportParameters();
        parameters.setBase64EncodedCertificate(base64EncodedCertificate);
        parameters.setPassword(password);
        parameters.setCertificatePolicy(certificatePolicy);
        parameters.setCertificateAttributes(null);
        parameters.setTags(null);
        this.restClient().setBaseUrl("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.importCertificate(certificateName, this.apiVersion(), this.acceptLanguage(), parameters, this.userAgent());
        final ServiceCall serviceCall = new ServiceCall(call);
        call.enqueue(new ServiceResponseCallback<CertificateBundleInner>(serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    serviceCallback.success(importCertificateDelegate(response));
                } catch (KeyVaultErrorException | IOException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    /**
     * Imports a certificate into the specified vault.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param certificateName The name of the certificate
     * @param base64EncodedCertificate Base64 encoded representaion of the certificate object to import. This certificate needs to contain the private key.
     * @param password If the private key in base64EncodedCertificate is encrypted, the password used for encryption
     * @param certificatePolicy The management policy for the certificate
     * @param certificateAttributes The attributes of the certificate (optional)
     * @param tags Application-specific metadata in the form of key-value pairs
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the CertificateBundleInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<CertificateBundleInner> importCertificate(String vaultBaseUrl, String certificateName, String base64EncodedCertificate, String password, CertificatePolicyInner certificatePolicy, CertificateAttributesInner certificateAttributes, Map<String, String> tags) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (certificateName == null) {
            throw new IllegalArgumentException("Parameter certificateName is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        if (base64EncodedCertificate == null) {
            throw new IllegalArgumentException("Parameter base64EncodedCertificate is required and cannot be null.");
        }
        if (password == null) {
            throw new IllegalArgumentException("Parameter password is required and cannot be null.");
        }
        if (certificatePolicy == null) {
            throw new IllegalArgumentException("Parameter certificatePolicy is required and cannot be null.");
        }
        Validator.validate(certificatePolicy);
        Validator.validate(certificateAttributes);
        Validator.validate(tags);
        CertificateImportParameters parameters = new CertificateImportParameters();
        parameters.setBase64EncodedCertificate(base64EncodedCertificate);
        parameters.setPassword(password);
        parameters.setCertificatePolicy(certificatePolicy);
        parameters.setCertificateAttributes(certificateAttributes);
        parameters.setTags(tags);
        this.restClient().setBaseUrl("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.importCertificate(certificateName, this.apiVersion(), this.acceptLanguage(), parameters, this.userAgent());
        return importCertificateDelegate(call.execute());
    }

    /**
     * Imports a certificate into the specified vault.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param certificateName The name of the certificate
     * @param base64EncodedCertificate Base64 encoded representaion of the certificate object to import. This certificate needs to contain the private key.
     * @param password If the private key in base64EncodedCertificate is encrypted, the password used for encryption
     * @param certificatePolicy The management policy for the certificate
     * @param certificateAttributes The attributes of the certificate (optional)
     * @param tags Application-specific metadata in the form of key-value pairs
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if callback is null
     * @return the {@link Call} object
     */
    public ServiceCall importCertificateAsync(String vaultBaseUrl, String certificateName, String base64EncodedCertificate, String password, CertificatePolicyInner certificatePolicy, CertificateAttributesInner certificateAttributes, Map<String, String> tags, final ServiceCallback<CertificateBundleInner> serviceCallback) throws IllegalArgumentException {
        if (serviceCallback == null) {
            throw new IllegalArgumentException("ServiceCallback is required for async calls.");
        }
        if (vaultBaseUrl == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null."));
            return null;
        }
        if (certificateName == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter certificateName is required and cannot be null."));
            return null;
        }
        if (this.apiVersion() == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null."));
            return null;
        }
        if (base64EncodedCertificate == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter base64EncodedCertificate is required and cannot be null."));
            return null;
        }
        if (password == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter password is required and cannot be null."));
            return null;
        }
        if (certificatePolicy == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter certificatePolicy is required and cannot be null."));
            return null;
        }
        Validator.validate(certificatePolicy, serviceCallback);
        Validator.validate(certificateAttributes, serviceCallback);
        Validator.validate(tags, serviceCallback);
        CertificateImportParameters parameters = new CertificateImportParameters();
        parameters.setBase64EncodedCertificate(base64EncodedCertificate);
        parameters.setPassword(password);
        parameters.setCertificatePolicy(certificatePolicy);
        parameters.setCertificateAttributes(certificateAttributes);
        parameters.setTags(tags);
        this.restClient().setBaseUrl("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.importCertificate(certificateName, this.apiVersion(), this.acceptLanguage(), parameters, this.userAgent());
        final ServiceCall serviceCall = new ServiceCall(call);
        call.enqueue(new ServiceResponseCallback<CertificateBundleInner>(serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    serviceCallback.success(importCertificateDelegate(response));
                } catch (KeyVaultErrorException | IOException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<CertificateBundleInner> importCertificateDelegate(Response<ResponseBody> response) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<CertificateBundleInner, KeyVaultErrorException>(this.restClient().mapperAdapter())
                .register(200, new TypeToken<CertificateBundleInner>() { }.getType())
                .registerError(KeyVaultErrorException.class)
                .build(response);
    }

    /**
     * List the versions of a certificate.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param certificateName The name of the certificate
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;CertificateItemInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PagedList<CertificateItemInner>> getCertificateVersions(final String vaultBaseUrl, final String certificateName) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (certificateName == null) {
            throw new IllegalArgumentException("Parameter certificateName is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        final Integer maxresults = null;
        this.restClient().setBaseUrl("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.getCertificateVersions(certificateName, maxresults, this.apiVersion(), this.acceptLanguage(), this.userAgent());
        ServiceResponse<PageImpl<CertificateItemInner>> response = getCertificateVersionsDelegate(call.execute());
        PagedList<CertificateItemInner> result = new PagedList<CertificateItemInner>(response.getBody()) {
            @Override
            public Page<CertificateItemInner> nextPage(String nextPageLink) throws KeyVaultErrorException, IOException {
                return getCertificateVersionsNext(nextPageLink).getBody();
            }
        };
        return new ServiceResponse<>(result, response.getResponse());
    }

    /**
     * List the versions of a certificate.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param certificateName The name of the certificate
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if callback is null
     * @return the {@link Call} object
     */
    public ServiceCall getCertificateVersionsAsync(final String vaultBaseUrl, final String certificateName, final ListOperationCallback<CertificateItemInner> serviceCallback) throws IllegalArgumentException {
        if (serviceCallback == null) {
            throw new IllegalArgumentException("ServiceCallback is required for async calls.");
        }
        if (vaultBaseUrl == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null."));
            return null;
        }
        if (certificateName == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter certificateName is required and cannot be null."));
            return null;
        }
        if (this.apiVersion() == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null."));
            return null;
        }
        final Integer maxresults = null;
        this.restClient().setBaseUrl("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.getCertificateVersions(certificateName, maxresults, this.apiVersion(), this.acceptLanguage(), this.userAgent());
        final ServiceCall serviceCall = new ServiceCall(call);
        call.enqueue(new ServiceResponseCallback<List<CertificateItemInner>>(serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<PageImpl<CertificateItemInner>> result = getCertificateVersionsDelegate(response);
                    serviceCallback.load(result.getBody().getItems());
                    if (result.getBody().getNextPageLink() != null
                            && serviceCallback.progress(result.getBody().getItems()) == ListOperationCallback.PagingBahavior.CONTINUE) {
                        getCertificateVersionsNextAsync(result.getBody().getNextPageLink(), serviceCall, serviceCallback);
                    } else {
                        serviceCallback.success(new ServiceResponse<>(serviceCallback.get(), result.getResponse()));
                    }
                } catch (KeyVaultErrorException | IOException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    /**
     * List the versions of a certificate.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param certificateName The name of the certificate
     * @param maxresults Maximum number of results to return.
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;CertificateItemInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PagedList<CertificateItemInner>> getCertificateVersions(final String vaultBaseUrl, final String certificateName, final Integer maxresults) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (certificateName == null) {
            throw new IllegalArgumentException("Parameter certificateName is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        this.restClient().setBaseUrl("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.getCertificateVersions(certificateName, maxresults, this.apiVersion(), this.acceptLanguage(), this.userAgent());
        ServiceResponse<PageImpl<CertificateItemInner>> response = getCertificateVersionsDelegate(call.execute());
        PagedList<CertificateItemInner> result = new PagedList<CertificateItemInner>(response.getBody()) {
            @Override
            public Page<CertificateItemInner> nextPage(String nextPageLink) throws KeyVaultErrorException, IOException {
                return getCertificateVersionsNext(nextPageLink).getBody();
            }
        };
        return new ServiceResponse<>(result, response.getResponse());
    }

    /**
     * List the versions of a certificate.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param certificateName The name of the certificate
     * @param maxresults Maximum number of results to return.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if callback is null
     * @return the {@link Call} object
     */
    public ServiceCall getCertificateVersionsAsync(final String vaultBaseUrl, final String certificateName, final Integer maxresults, final ListOperationCallback<CertificateItemInner> serviceCallback) throws IllegalArgumentException {
        if (serviceCallback == null) {
            throw new IllegalArgumentException("ServiceCallback is required for async calls.");
        }
        if (vaultBaseUrl == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null."));
            return null;
        }
        if (certificateName == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter certificateName is required and cannot be null."));
            return null;
        }
        if (this.apiVersion() == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null."));
            return null;
        }
        this.restClient().setBaseUrl("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.getCertificateVersions(certificateName, maxresults, this.apiVersion(), this.acceptLanguage(), this.userAgent());
        final ServiceCall serviceCall = new ServiceCall(call);
        call.enqueue(new ServiceResponseCallback<List<CertificateItemInner>>(serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<PageImpl<CertificateItemInner>> result = getCertificateVersionsDelegate(response);
                    serviceCallback.load(result.getBody().getItems());
                    if (result.getBody().getNextPageLink() != null
                            && serviceCallback.progress(result.getBody().getItems()) == ListOperationCallback.PagingBahavior.CONTINUE) {
                        getCertificateVersionsNextAsync(result.getBody().getNextPageLink(), serviceCall, serviceCallback);
                    } else {
                        serviceCallback.success(new ServiceResponse<>(serviceCallback.get(), result.getResponse()));
                    }
                } catch (KeyVaultErrorException | IOException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<PageImpl<CertificateItemInner>> getCertificateVersionsDelegate(Response<ResponseBody> response) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<CertificateItemInner>, KeyVaultErrorException>(this.restClient().mapperAdapter())
                .register(200, new TypeToken<PageImpl<CertificateItemInner>>() { }.getType())
                .registerError(KeyVaultErrorException.class)
                .build(response);
    }

    /**
     * Gets the policy for a certificate.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param certificateName The name of the certificate in the given vault.
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the CertificatePolicyInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<CertificatePolicyInner> getCertificatePolicy(String vaultBaseUrl, String certificateName) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (certificateName == null) {
            throw new IllegalArgumentException("Parameter certificateName is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        this.restClient().setBaseUrl("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.getCertificatePolicy(certificateName, this.apiVersion(), this.acceptLanguage(), this.userAgent());
        return getCertificatePolicyDelegate(call.execute());
    }

    /**
     * Gets the policy for a certificate.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param certificateName The name of the certificate in the given vault.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if callback is null
     * @return the {@link Call} object
     */
    public ServiceCall getCertificatePolicyAsync(String vaultBaseUrl, String certificateName, final ServiceCallback<CertificatePolicyInner> serviceCallback) throws IllegalArgumentException {
        if (serviceCallback == null) {
            throw new IllegalArgumentException("ServiceCallback is required for async calls.");
        }
        if (vaultBaseUrl == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null."));
            return null;
        }
        if (certificateName == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter certificateName is required and cannot be null."));
            return null;
        }
        if (this.apiVersion() == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null."));
            return null;
        }
        this.restClient().setBaseUrl("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.getCertificatePolicy(certificateName, this.apiVersion(), this.acceptLanguage(), this.userAgent());
        final ServiceCall serviceCall = new ServiceCall(call);
        call.enqueue(new ServiceResponseCallback<CertificatePolicyInner>(serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    serviceCallback.success(getCertificatePolicyDelegate(response));
                } catch (KeyVaultErrorException | IOException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<CertificatePolicyInner> getCertificatePolicyDelegate(Response<ResponseBody> response) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<CertificatePolicyInner, KeyVaultErrorException>(this.restClient().mapperAdapter())
                .register(200, new TypeToken<CertificatePolicyInner>() { }.getType())
                .registerError(KeyVaultErrorException.class)
                .build(response);
    }

    /**
     * Updates the policy for a certificate. Set appropriate members in the certificatePolicy that must be updated. Leave others as null.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param certificateName The name of the certificate in the given vault.
     * @param certificatePolicy The policy for the certificate.
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the CertificatePolicyInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<CertificatePolicyInner> updateCertificatePolicy(String vaultBaseUrl, String certificateName, CertificatePolicyInner certificatePolicy) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (certificateName == null) {
            throw new IllegalArgumentException("Parameter certificateName is required and cannot be null.");
        }
        if (certificatePolicy == null) {
            throw new IllegalArgumentException("Parameter certificatePolicy is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        Validator.validate(certificatePolicy);
        this.restClient().setBaseUrl("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.updateCertificatePolicy(certificateName, certificatePolicy, this.apiVersion(), this.acceptLanguage(), this.userAgent());
        return updateCertificatePolicyDelegate(call.execute());
    }

    /**
     * Updates the policy for a certificate. Set appropriate members in the certificatePolicy that must be updated. Leave others as null.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param certificateName The name of the certificate in the given vault.
     * @param certificatePolicy The policy for the certificate.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if callback is null
     * @return the {@link Call} object
     */
    public ServiceCall updateCertificatePolicyAsync(String vaultBaseUrl, String certificateName, CertificatePolicyInner certificatePolicy, final ServiceCallback<CertificatePolicyInner> serviceCallback) throws IllegalArgumentException {
        if (serviceCallback == null) {
            throw new IllegalArgumentException("ServiceCallback is required for async calls.");
        }
        if (vaultBaseUrl == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null."));
            return null;
        }
        if (certificateName == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter certificateName is required and cannot be null."));
            return null;
        }
        if (certificatePolicy == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter certificatePolicy is required and cannot be null."));
            return null;
        }
        if (this.apiVersion() == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null."));
            return null;
        }
        Validator.validate(certificatePolicy, serviceCallback);
        this.restClient().setBaseUrl("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.updateCertificatePolicy(certificateName, certificatePolicy, this.apiVersion(), this.acceptLanguage(), this.userAgent());
        final ServiceCall serviceCall = new ServiceCall(call);
        call.enqueue(new ServiceResponseCallback<CertificatePolicyInner>(serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    serviceCallback.success(updateCertificatePolicyDelegate(response));
                } catch (KeyVaultErrorException | IOException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<CertificatePolicyInner> updateCertificatePolicyDelegate(Response<ResponseBody> response) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<CertificatePolicyInner, KeyVaultErrorException>(this.restClient().mapperAdapter())
                .register(200, new TypeToken<CertificatePolicyInner>() { }.getType())
                .registerError(KeyVaultErrorException.class)
                .build(response);
    }

    /**
     * Updates the attributes associated with the specified certificate.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param certificateName The name of the certificate in the given vault
     * @param certificateVersion The version of the certificate
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the CertificateBundleInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<CertificateBundleInner> updateCertificate(String vaultBaseUrl, String certificateName, String certificateVersion) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (certificateName == null) {
            throw new IllegalArgumentException("Parameter certificateName is required and cannot be null.");
        }
        if (certificateVersion == null) {
            throw new IllegalArgumentException("Parameter certificateVersion is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        final CertificateAttributesInner certificateAttributes = null;
        final Map<String, String> tags = null;
        CertificateUpdateParameters parameters = new CertificateUpdateParameters();
        parameters.setCertificateAttributes(null);
        parameters.setTags(null);
        this.restClient().setBaseUrl("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.updateCertificate(certificateName, certificateVersion, this.apiVersion(), this.acceptLanguage(), parameters, this.userAgent());
        return updateCertificateDelegate(call.execute());
    }

    /**
     * Updates the attributes associated with the specified certificate.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param certificateName The name of the certificate in the given vault
     * @param certificateVersion The version of the certificate
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if callback is null
     * @return the {@link Call} object
     */
    public ServiceCall updateCertificateAsync(String vaultBaseUrl, String certificateName, String certificateVersion, final ServiceCallback<CertificateBundleInner> serviceCallback) throws IllegalArgumentException {
        if (serviceCallback == null) {
            throw new IllegalArgumentException("ServiceCallback is required for async calls.");
        }
        if (vaultBaseUrl == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null."));
            return null;
        }
        if (certificateName == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter certificateName is required and cannot be null."));
            return null;
        }
        if (certificateVersion == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter certificateVersion is required and cannot be null."));
            return null;
        }
        if (this.apiVersion() == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null."));
            return null;
        }
        final CertificateAttributesInner certificateAttributes = null;
        final Map<String, String> tags = null;
        CertificateUpdateParameters parameters = new CertificateUpdateParameters();
        parameters.setCertificateAttributes(null);
        parameters.setTags(null);
        this.restClient().setBaseUrl("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.updateCertificate(certificateName, certificateVersion, this.apiVersion(), this.acceptLanguage(), parameters, this.userAgent());
        final ServiceCall serviceCall = new ServiceCall(call);
        call.enqueue(new ServiceResponseCallback<CertificateBundleInner>(serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    serviceCallback.success(updateCertificateDelegate(response));
                } catch (KeyVaultErrorException | IOException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    /**
     * Updates the attributes associated with the specified certificate.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param certificateName The name of the certificate in the given vault
     * @param certificateVersion The version of the certificate
     * @param certificateAttributes The attributes of the certificate (optional)
     * @param tags Application-specific metadata in the form of key-value pairs
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the CertificateBundleInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<CertificateBundleInner> updateCertificate(String vaultBaseUrl, String certificateName, String certificateVersion, CertificateAttributesInner certificateAttributes, Map<String, String> tags) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (certificateName == null) {
            throw new IllegalArgumentException("Parameter certificateName is required and cannot be null.");
        }
        if (certificateVersion == null) {
            throw new IllegalArgumentException("Parameter certificateVersion is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        Validator.validate(certificateAttributes);
        Validator.validate(tags);
        CertificateUpdateParameters parameters = new CertificateUpdateParameters();
        parameters.setCertificateAttributes(certificateAttributes);
        parameters.setTags(tags);
        this.restClient().setBaseUrl("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.updateCertificate(certificateName, certificateVersion, this.apiVersion(), this.acceptLanguage(), parameters, this.userAgent());
        return updateCertificateDelegate(call.execute());
    }

    /**
     * Updates the attributes associated with the specified certificate.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param certificateName The name of the certificate in the given vault
     * @param certificateVersion The version of the certificate
     * @param certificateAttributes The attributes of the certificate (optional)
     * @param tags Application-specific metadata in the form of key-value pairs
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if callback is null
     * @return the {@link Call} object
     */
    public ServiceCall updateCertificateAsync(String vaultBaseUrl, String certificateName, String certificateVersion, CertificateAttributesInner certificateAttributes, Map<String, String> tags, final ServiceCallback<CertificateBundleInner> serviceCallback) throws IllegalArgumentException {
        if (serviceCallback == null) {
            throw new IllegalArgumentException("ServiceCallback is required for async calls.");
        }
        if (vaultBaseUrl == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null."));
            return null;
        }
        if (certificateName == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter certificateName is required and cannot be null."));
            return null;
        }
        if (certificateVersion == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter certificateVersion is required and cannot be null."));
            return null;
        }
        if (this.apiVersion() == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null."));
            return null;
        }
        Validator.validate(certificateAttributes, serviceCallback);
        Validator.validate(tags, serviceCallback);
        CertificateUpdateParameters parameters = new CertificateUpdateParameters();
        parameters.setCertificateAttributes(certificateAttributes);
        parameters.setTags(tags);
        this.restClient().setBaseUrl("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.updateCertificate(certificateName, certificateVersion, this.apiVersion(), this.acceptLanguage(), parameters, this.userAgent());
        final ServiceCall serviceCall = new ServiceCall(call);
        call.enqueue(new ServiceResponseCallback<CertificateBundleInner>(serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    serviceCallback.success(updateCertificateDelegate(response));
                } catch (KeyVaultErrorException | IOException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<CertificateBundleInner> updateCertificateDelegate(Response<ResponseBody> response) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<CertificateBundleInner, KeyVaultErrorException>(this.restClient().mapperAdapter())
                .register(200, new TypeToken<CertificateBundleInner>() { }.getType())
                .registerError(KeyVaultErrorException.class)
                .build(response);
    }

    /**
     * Gets a Certificate.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param certificateName The name of the certificate in the given vault
     * @param certificateVersion The version of the certificate
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the CertificateBundleInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<CertificateBundleInner> getCertificate(String vaultBaseUrl, String certificateName, String certificateVersion) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (certificateName == null) {
            throw new IllegalArgumentException("Parameter certificateName is required and cannot be null.");
        }
        if (certificateVersion == null) {
            throw new IllegalArgumentException("Parameter certificateVersion is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        this.restClient().setBaseUrl("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.getCertificate(certificateName, certificateVersion, this.apiVersion(), this.acceptLanguage(), this.userAgent());
        return getCertificateDelegate(call.execute());
    }

    /**
     * Gets a Certificate.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param certificateName The name of the certificate in the given vault
     * @param certificateVersion The version of the certificate
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if callback is null
     * @return the {@link Call} object
     */
    public ServiceCall getCertificateAsync(String vaultBaseUrl, String certificateName, String certificateVersion, final ServiceCallback<CertificateBundleInner> serviceCallback) throws IllegalArgumentException {
        if (serviceCallback == null) {
            throw new IllegalArgumentException("ServiceCallback is required for async calls.");
        }
        if (vaultBaseUrl == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null."));
            return null;
        }
        if (certificateName == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter certificateName is required and cannot be null."));
            return null;
        }
        if (certificateVersion == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter certificateVersion is required and cannot be null."));
            return null;
        }
        if (this.apiVersion() == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null."));
            return null;
        }
        this.restClient().setBaseUrl("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.getCertificate(certificateName, certificateVersion, this.apiVersion(), this.acceptLanguage(), this.userAgent());
        final ServiceCall serviceCall = new ServiceCall(call);
        call.enqueue(new ServiceResponseCallback<CertificateBundleInner>(serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    serviceCallback.success(getCertificateDelegate(response));
                } catch (KeyVaultErrorException | IOException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<CertificateBundleInner> getCertificateDelegate(Response<ResponseBody> response) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<CertificateBundleInner, KeyVaultErrorException>(this.restClient().mapperAdapter())
                .register(200, new TypeToken<CertificateBundleInner>() { }.getType())
                .registerError(KeyVaultErrorException.class)
                .build(response);
    }

    /**
     * Updates a certificate operation.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param certificateName The name of the certificate
     * @param certificateOperation The certificate operation response.
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the CertificateOperationInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<CertificateOperationInner> updateCertificateOperation(String vaultBaseUrl, String certificateName, CertificateOperationInner certificateOperation) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (certificateName == null) {
            throw new IllegalArgumentException("Parameter certificateName is required and cannot be null.");
        }
        if (certificateOperation == null) {
            throw new IllegalArgumentException("Parameter certificateOperation is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        Validator.validate(certificateOperation);
        this.restClient().setBaseUrl("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.updateCertificateOperation(certificateName, certificateOperation, this.apiVersion(), this.acceptLanguage(), this.userAgent());
        return updateCertificateOperationDelegate(call.execute());
    }

    /**
     * Updates a certificate operation.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param certificateName The name of the certificate
     * @param certificateOperation The certificate operation response.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if callback is null
     * @return the {@link Call} object
     */
    public ServiceCall updateCertificateOperationAsync(String vaultBaseUrl, String certificateName, CertificateOperationInner certificateOperation, final ServiceCallback<CertificateOperationInner> serviceCallback) throws IllegalArgumentException {
        if (serviceCallback == null) {
            throw new IllegalArgumentException("ServiceCallback is required for async calls.");
        }
        if (vaultBaseUrl == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null."));
            return null;
        }
        if (certificateName == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter certificateName is required and cannot be null."));
            return null;
        }
        if (certificateOperation == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter certificateOperation is required and cannot be null."));
            return null;
        }
        if (this.apiVersion() == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null."));
            return null;
        }
        Validator.validate(certificateOperation, serviceCallback);
        this.restClient().setBaseUrl("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.updateCertificateOperation(certificateName, certificateOperation, this.apiVersion(), this.acceptLanguage(), this.userAgent());
        final ServiceCall serviceCall = new ServiceCall(call);
        call.enqueue(new ServiceResponseCallback<CertificateOperationInner>(serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    serviceCallback.success(updateCertificateOperationDelegate(response));
                } catch (KeyVaultErrorException | IOException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<CertificateOperationInner> updateCertificateOperationDelegate(Response<ResponseBody> response) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<CertificateOperationInner, KeyVaultErrorException>(this.restClient().mapperAdapter())
                .register(200, new TypeToken<CertificateOperationInner>() { }.getType())
                .registerError(KeyVaultErrorException.class)
                .build(response);
    }

    /**
     * Gets the certificate operation response.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param certificateName The name of the certificate
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the CertificateOperationInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<CertificateOperationInner> getCertificateOperation(String vaultBaseUrl, String certificateName) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (certificateName == null) {
            throw new IllegalArgumentException("Parameter certificateName is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        this.restClient().setBaseUrl("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.getCertificateOperation(certificateName, this.apiVersion(), this.acceptLanguage(), this.userAgent());
        return getCertificateOperationDelegate(call.execute());
    }

    /**
     * Gets the certificate operation response.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param certificateName The name of the certificate
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if callback is null
     * @return the {@link Call} object
     */
    public ServiceCall getCertificateOperationAsync(String vaultBaseUrl, String certificateName, final ServiceCallback<CertificateOperationInner> serviceCallback) throws IllegalArgumentException {
        if (serviceCallback == null) {
            throw new IllegalArgumentException("ServiceCallback is required for async calls.");
        }
        if (vaultBaseUrl == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null."));
            return null;
        }
        if (certificateName == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter certificateName is required and cannot be null."));
            return null;
        }
        if (this.apiVersion() == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null."));
            return null;
        }
        this.restClient().setBaseUrl("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.getCertificateOperation(certificateName, this.apiVersion(), this.acceptLanguage(), this.userAgent());
        final ServiceCall serviceCall = new ServiceCall(call);
        call.enqueue(new ServiceResponseCallback<CertificateOperationInner>(serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    serviceCallback.success(getCertificateOperationDelegate(response));
                } catch (KeyVaultErrorException | IOException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<CertificateOperationInner> getCertificateOperationDelegate(Response<ResponseBody> response) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<CertificateOperationInner, KeyVaultErrorException>(this.restClient().mapperAdapter())
                .register(200, new TypeToken<CertificateOperationInner>() { }.getType())
                .registerError(KeyVaultErrorException.class)
                .build(response);
    }

    /**
     * Deletes the certificate operation.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param certificateName The name of the certificate
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the CertificateOperationInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<CertificateOperationInner> deleteCertificateOperation(String vaultBaseUrl, String certificateName) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (certificateName == null) {
            throw new IllegalArgumentException("Parameter certificateName is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        this.restClient().setBaseUrl("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.deleteCertificateOperation(certificateName, this.apiVersion(), this.acceptLanguage(), this.userAgent());
        return deleteCertificateOperationDelegate(call.execute());
    }

    /**
     * Deletes the certificate operation.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param certificateName The name of the certificate
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if callback is null
     * @return the {@link Call} object
     */
    public ServiceCall deleteCertificateOperationAsync(String vaultBaseUrl, String certificateName, final ServiceCallback<CertificateOperationInner> serviceCallback) throws IllegalArgumentException {
        if (serviceCallback == null) {
            throw new IllegalArgumentException("ServiceCallback is required for async calls.");
        }
        if (vaultBaseUrl == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null."));
            return null;
        }
        if (certificateName == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter certificateName is required and cannot be null."));
            return null;
        }
        if (this.apiVersion() == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null."));
            return null;
        }
        this.restClient().setBaseUrl("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.deleteCertificateOperation(certificateName, this.apiVersion(), this.acceptLanguage(), this.userAgent());
        final ServiceCall serviceCall = new ServiceCall(call);
        call.enqueue(new ServiceResponseCallback<CertificateOperationInner>(serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    serviceCallback.success(deleteCertificateOperationDelegate(response));
                } catch (KeyVaultErrorException | IOException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<CertificateOperationInner> deleteCertificateOperationDelegate(Response<ResponseBody> response) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<CertificateOperationInner, KeyVaultErrorException>(this.restClient().mapperAdapter())
                .register(200, new TypeToken<CertificateOperationInner>() { }.getType())
                .registerError(KeyVaultErrorException.class)
                .build(response);
    }

    /**
     * Merges a certificate or a certificate chain with a key pair existing on the server.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param certificateName The name of the certificate
     * @param x509Certificates The certificate or the certificte chain to merge
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the CertificateBundleInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<CertificateBundleInner> mergeCertificate(String vaultBaseUrl, String certificateName, List<byte[]> x509Certificates) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (certificateName == null) {
            throw new IllegalArgumentException("Parameter certificateName is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        if (x509Certificates == null) {
            throw new IllegalArgumentException("Parameter x509Certificates is required and cannot be null.");
        }
        Validator.validate(x509Certificates);
        final CertificateAttributesInner certificateAttributes = null;
        final Map<String, String> tags = null;
        CertificateMergeParameters parameters = new CertificateMergeParameters();
        parameters.setX509Certificates(x509Certificates);
        parameters.setCertificateAttributes(null);
        parameters.setTags(null);
        this.restClient().setBaseUrl("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.mergeCertificate(certificateName, this.apiVersion(), this.acceptLanguage(), parameters, this.userAgent());
        return mergeCertificateDelegate(call.execute());
    }

    /**
     * Merges a certificate or a certificate chain with a key pair existing on the server.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param certificateName The name of the certificate
     * @param x509Certificates The certificate or the certificte chain to merge
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if callback is null
     * @return the {@link Call} object
     */
    public ServiceCall mergeCertificateAsync(String vaultBaseUrl, String certificateName, List<byte[]> x509Certificates, final ServiceCallback<CertificateBundleInner> serviceCallback) throws IllegalArgumentException {
        if (serviceCallback == null) {
            throw new IllegalArgumentException("ServiceCallback is required for async calls.");
        }
        if (vaultBaseUrl == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null."));
            return null;
        }
        if (certificateName == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter certificateName is required and cannot be null."));
            return null;
        }
        if (this.apiVersion() == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null."));
            return null;
        }
        if (x509Certificates == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter x509Certificates is required and cannot be null."));
            return null;
        }
        Validator.validate(x509Certificates, serviceCallback);
        final CertificateAttributesInner certificateAttributes = null;
        final Map<String, String> tags = null;
        CertificateMergeParameters parameters = new CertificateMergeParameters();
        parameters.setX509Certificates(x509Certificates);
        parameters.setCertificateAttributes(null);
        parameters.setTags(null);
        this.restClient().setBaseUrl("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.mergeCertificate(certificateName, this.apiVersion(), this.acceptLanguage(), parameters, this.userAgent());
        final ServiceCall serviceCall = new ServiceCall(call);
        call.enqueue(new ServiceResponseCallback<CertificateBundleInner>(serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    serviceCallback.success(mergeCertificateDelegate(response));
                } catch (KeyVaultErrorException | IOException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    /**
     * Merges a certificate or a certificate chain with a key pair existing on the server.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param certificateName The name of the certificate
     * @param x509Certificates The certificate or the certificte chain to merge
     * @param certificateAttributes The attributes of the certificate (optional)
     * @param tags Application-specific metadata in the form of key-value pairs
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the CertificateBundleInner object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<CertificateBundleInner> mergeCertificate(String vaultBaseUrl, String certificateName, List<byte[]> x509Certificates, CertificateAttributesInner certificateAttributes, Map<String, String> tags) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (vaultBaseUrl == null) {
            throw new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null.");
        }
        if (certificateName == null) {
            throw new IllegalArgumentException("Parameter certificateName is required and cannot be null.");
        }
        if (this.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null.");
        }
        if (x509Certificates == null) {
            throw new IllegalArgumentException("Parameter x509Certificates is required and cannot be null.");
        }
        Validator.validate(x509Certificates);
        Validator.validate(certificateAttributes);
        Validator.validate(tags);
        CertificateMergeParameters parameters = new CertificateMergeParameters();
        parameters.setX509Certificates(x509Certificates);
        parameters.setCertificateAttributes(certificateAttributes);
        parameters.setTags(tags);
        this.restClient().setBaseUrl("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.mergeCertificate(certificateName, this.apiVersion(), this.acceptLanguage(), parameters, this.userAgent());
        return mergeCertificateDelegate(call.execute());
    }

    /**
     * Merges a certificate or a certificate chain with a key pair existing on the server.
     *
     * @param vaultBaseUrl The vault name, e.g. https://myvault.vault.azure.net
     * @param certificateName The name of the certificate
     * @param x509Certificates The certificate or the certificte chain to merge
     * @param certificateAttributes The attributes of the certificate (optional)
     * @param tags Application-specific metadata in the form of key-value pairs
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if callback is null
     * @return the {@link Call} object
     */
    public ServiceCall mergeCertificateAsync(String vaultBaseUrl, String certificateName, List<byte[]> x509Certificates, CertificateAttributesInner certificateAttributes, Map<String, String> tags, final ServiceCallback<CertificateBundleInner> serviceCallback) throws IllegalArgumentException {
        if (serviceCallback == null) {
            throw new IllegalArgumentException("ServiceCallback is required for async calls.");
        }
        if (vaultBaseUrl == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter vaultBaseUrl is required and cannot be null."));
            return null;
        }
        if (certificateName == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter certificateName is required and cannot be null."));
            return null;
        }
        if (this.apiVersion() == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter this.apiVersion() is required and cannot be null."));
            return null;
        }
        if (x509Certificates == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter x509Certificates is required and cannot be null."));
            return null;
        }
        Validator.validate(x509Certificates, serviceCallback);
        Validator.validate(certificateAttributes, serviceCallback);
        Validator.validate(tags, serviceCallback);
        CertificateMergeParameters parameters = new CertificateMergeParameters();
        parameters.setX509Certificates(x509Certificates);
        parameters.setCertificateAttributes(certificateAttributes);
        parameters.setTags(tags);
        this.restClient().setBaseUrl("{vaultBaseUrl}", vaultBaseUrl);
        Call<ResponseBody> call = service.mergeCertificate(certificateName, this.apiVersion(), this.acceptLanguage(), parameters, this.userAgent());
        final ServiceCall serviceCall = new ServiceCall(call);
        call.enqueue(new ServiceResponseCallback<CertificateBundleInner>(serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    serviceCallback.success(mergeCertificateDelegate(response));
                } catch (KeyVaultErrorException | IOException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<CertificateBundleInner> mergeCertificateDelegate(Response<ResponseBody> response) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<CertificateBundleInner, KeyVaultErrorException>(this.restClient().mapperAdapter())
                .register(201, new TypeToken<CertificateBundleInner>() { }.getType())
                .registerError(KeyVaultErrorException.class)
                .build(response);
    }

    /**
     * List the versions of the specified key.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;KeyItemInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PageImpl<KeyItemInner>> getKeyVersionsNext(final String nextPageLink) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        this.restClient().setBaseUrl();
        Call<ResponseBody> call = service.getKeyVersionsNext(nextPageLink, this.acceptLanguage(), this.userAgent());
        return getKeyVersionsNextDelegate(call.execute());
    }

    /**
     * List the versions of the specified key.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceCall the ServiceCall object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if callback is null
     * @return the {@link Call} object
     */
    public ServiceCall getKeyVersionsNextAsync(final String nextPageLink, final ServiceCall serviceCall, final ListOperationCallback<KeyItemInner> serviceCallback) throws IllegalArgumentException {
        if (serviceCallback == null) {
            throw new IllegalArgumentException("ServiceCallback is required for async calls.");
        }
        if (nextPageLink == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter nextPageLink is required and cannot be null."));
            return null;
        }
        this.restClient().setBaseUrl();
        Call<ResponseBody> call = service.getKeyVersionsNext(nextPageLink, this.acceptLanguage(), this.userAgent());
        serviceCall.newCall(call);
        call.enqueue(new ServiceResponseCallback<List<KeyItemInner>>(serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<PageImpl<KeyItemInner>> result = getKeyVersionsNextDelegate(response);
                    serviceCallback.load(result.getBody().getItems());
                    if (result.getBody().getNextPageLink() != null
                            && serviceCallback.progress(result.getBody().getItems()) == ListOperationCallback.PagingBahavior.CONTINUE) {
                        getKeyVersionsNextAsync(result.getBody().getNextPageLink(), serviceCall, serviceCallback);
                    } else {
                        serviceCallback.success(new ServiceResponse<>(serviceCallback.get(), result.getResponse()));
                    }
                } catch (KeyVaultErrorException | IOException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<PageImpl<KeyItemInner>> getKeyVersionsNextDelegate(Response<ResponseBody> response) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<KeyItemInner>, KeyVaultErrorException>(this.restClient().mapperAdapter())
                .register(200, new TypeToken<PageImpl<KeyItemInner>>() { }.getType())
                .registerError(KeyVaultErrorException.class)
                .build(response);
    }

    /**
     * List keys in the specified vault.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;KeyItemInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PageImpl<KeyItemInner>> getKeysNext(final String nextPageLink) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        this.restClient().setBaseUrl();
        Call<ResponseBody> call = service.getKeysNext(nextPageLink, this.acceptLanguage(), this.userAgent());
        return getKeysNextDelegate(call.execute());
    }

    /**
     * List keys in the specified vault.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceCall the ServiceCall object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if callback is null
     * @return the {@link Call} object
     */
    public ServiceCall getKeysNextAsync(final String nextPageLink, final ServiceCall serviceCall, final ListOperationCallback<KeyItemInner> serviceCallback) throws IllegalArgumentException {
        if (serviceCallback == null) {
            throw new IllegalArgumentException("ServiceCallback is required for async calls.");
        }
        if (nextPageLink == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter nextPageLink is required and cannot be null."));
            return null;
        }
        this.restClient().setBaseUrl();
        Call<ResponseBody> call = service.getKeysNext(nextPageLink, this.acceptLanguage(), this.userAgent());
        serviceCall.newCall(call);
        call.enqueue(new ServiceResponseCallback<List<KeyItemInner>>(serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<PageImpl<KeyItemInner>> result = getKeysNextDelegate(response);
                    serviceCallback.load(result.getBody().getItems());
                    if (result.getBody().getNextPageLink() != null
                            && serviceCallback.progress(result.getBody().getItems()) == ListOperationCallback.PagingBahavior.CONTINUE) {
                        getKeysNextAsync(result.getBody().getNextPageLink(), serviceCall, serviceCallback);
                    } else {
                        serviceCallback.success(new ServiceResponse<>(serviceCallback.get(), result.getResponse()));
                    }
                } catch (KeyVaultErrorException | IOException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<PageImpl<KeyItemInner>> getKeysNextDelegate(Response<ResponseBody> response) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<KeyItemInner>, KeyVaultErrorException>(this.restClient().mapperAdapter())
                .register(200, new TypeToken<PageImpl<KeyItemInner>>() { }.getType())
                .registerError(KeyVaultErrorException.class)
                .build(response);
    }

    /**
     * List secrets in the specified vault.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;SecretItemInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PageImpl<SecretItemInner>> getSecretsNext(final String nextPageLink) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        this.restClient().setBaseUrl();
        Call<ResponseBody> call = service.getSecretsNext(nextPageLink, this.acceptLanguage(), this.userAgent());
        return getSecretsNextDelegate(call.execute());
    }

    /**
     * List secrets in the specified vault.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceCall the ServiceCall object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if callback is null
     * @return the {@link Call} object
     */
    public ServiceCall getSecretsNextAsync(final String nextPageLink, final ServiceCall serviceCall, final ListOperationCallback<SecretItemInner> serviceCallback) throws IllegalArgumentException {
        if (serviceCallback == null) {
            throw new IllegalArgumentException("ServiceCallback is required for async calls.");
        }
        if (nextPageLink == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter nextPageLink is required and cannot be null."));
            return null;
        }
        this.restClient().setBaseUrl();
        Call<ResponseBody> call = service.getSecretsNext(nextPageLink, this.acceptLanguage(), this.userAgent());
        serviceCall.newCall(call);
        call.enqueue(new ServiceResponseCallback<List<SecretItemInner>>(serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<PageImpl<SecretItemInner>> result = getSecretsNextDelegate(response);
                    serviceCallback.load(result.getBody().getItems());
                    if (result.getBody().getNextPageLink() != null
                            && serviceCallback.progress(result.getBody().getItems()) == ListOperationCallback.PagingBahavior.CONTINUE) {
                        getSecretsNextAsync(result.getBody().getNextPageLink(), serviceCall, serviceCallback);
                    } else {
                        serviceCallback.success(new ServiceResponse<>(serviceCallback.get(), result.getResponse()));
                    }
                } catch (KeyVaultErrorException | IOException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<PageImpl<SecretItemInner>> getSecretsNextDelegate(Response<ResponseBody> response) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<SecretItemInner>, KeyVaultErrorException>(this.restClient().mapperAdapter())
                .register(200, new TypeToken<PageImpl<SecretItemInner>>() { }.getType())
                .registerError(KeyVaultErrorException.class)
                .build(response);
    }

    /**
     * List the versions of the specified secret.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;SecretItemInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PageImpl<SecretItemInner>> getSecretVersionsNext(final String nextPageLink) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        this.restClient().setBaseUrl();
        Call<ResponseBody> call = service.getSecretVersionsNext(nextPageLink, this.acceptLanguage(), this.userAgent());
        return getSecretVersionsNextDelegate(call.execute());
    }

    /**
     * List the versions of the specified secret.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceCall the ServiceCall object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if callback is null
     * @return the {@link Call} object
     */
    public ServiceCall getSecretVersionsNextAsync(final String nextPageLink, final ServiceCall serviceCall, final ListOperationCallback<SecretItemInner> serviceCallback) throws IllegalArgumentException {
        if (serviceCallback == null) {
            throw new IllegalArgumentException("ServiceCallback is required for async calls.");
        }
        if (nextPageLink == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter nextPageLink is required and cannot be null."));
            return null;
        }
        this.restClient().setBaseUrl();
        Call<ResponseBody> call = service.getSecretVersionsNext(nextPageLink, this.acceptLanguage(), this.userAgent());
        serviceCall.newCall(call);
        call.enqueue(new ServiceResponseCallback<List<SecretItemInner>>(serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<PageImpl<SecretItemInner>> result = getSecretVersionsNextDelegate(response);
                    serviceCallback.load(result.getBody().getItems());
                    if (result.getBody().getNextPageLink() != null
                            && serviceCallback.progress(result.getBody().getItems()) == ListOperationCallback.PagingBahavior.CONTINUE) {
                        getSecretVersionsNextAsync(result.getBody().getNextPageLink(), serviceCall, serviceCallback);
                    } else {
                        serviceCallback.success(new ServiceResponse<>(serviceCallback.get(), result.getResponse()));
                    }
                } catch (KeyVaultErrorException | IOException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<PageImpl<SecretItemInner>> getSecretVersionsNextDelegate(Response<ResponseBody> response) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<SecretItemInner>, KeyVaultErrorException>(this.restClient().mapperAdapter())
                .register(200, new TypeToken<PageImpl<SecretItemInner>>() { }.getType())
                .registerError(KeyVaultErrorException.class)
                .build(response);
    }

    /**
     * List certificates in the specified vault.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;CertificateItemInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PageImpl<CertificateItemInner>> getCertificatesNext(final String nextPageLink) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        this.restClient().setBaseUrl();
        Call<ResponseBody> call = service.getCertificatesNext(nextPageLink, this.acceptLanguage(), this.userAgent());
        return getCertificatesNextDelegate(call.execute());
    }

    /**
     * List certificates in the specified vault.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceCall the ServiceCall object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if callback is null
     * @return the {@link Call} object
     */
    public ServiceCall getCertificatesNextAsync(final String nextPageLink, final ServiceCall serviceCall, final ListOperationCallback<CertificateItemInner> serviceCallback) throws IllegalArgumentException {
        if (serviceCallback == null) {
            throw new IllegalArgumentException("ServiceCallback is required for async calls.");
        }
        if (nextPageLink == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter nextPageLink is required and cannot be null."));
            return null;
        }
        this.restClient().setBaseUrl();
        Call<ResponseBody> call = service.getCertificatesNext(nextPageLink, this.acceptLanguage(), this.userAgent());
        serviceCall.newCall(call);
        call.enqueue(new ServiceResponseCallback<List<CertificateItemInner>>(serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<PageImpl<CertificateItemInner>> result = getCertificatesNextDelegate(response);
                    serviceCallback.load(result.getBody().getItems());
                    if (result.getBody().getNextPageLink() != null
                            && serviceCallback.progress(result.getBody().getItems()) == ListOperationCallback.PagingBahavior.CONTINUE) {
                        getCertificatesNextAsync(result.getBody().getNextPageLink(), serviceCall, serviceCallback);
                    } else {
                        serviceCallback.success(new ServiceResponse<>(serviceCallback.get(), result.getResponse()));
                    }
                } catch (KeyVaultErrorException | IOException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<PageImpl<CertificateItemInner>> getCertificatesNextDelegate(Response<ResponseBody> response) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<CertificateItemInner>, KeyVaultErrorException>(this.restClient().mapperAdapter())
                .register(200, new TypeToken<PageImpl<CertificateItemInner>>() { }.getType())
                .registerError(KeyVaultErrorException.class)
                .build(response);
    }

    /**
     * List certificate issuers for the specified vault.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;CertificateIssuerItemInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PageImpl<CertificateIssuerItemInner>> getCertificateIssuersNext(final String nextPageLink) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        this.restClient().setBaseUrl();
        Call<ResponseBody> call = service.getCertificateIssuersNext(nextPageLink, this.acceptLanguage(), this.userAgent());
        return getCertificateIssuersNextDelegate(call.execute());
    }

    /**
     * List certificate issuers for the specified vault.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceCall the ServiceCall object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if callback is null
     * @return the {@link Call} object
     */
    public ServiceCall getCertificateIssuersNextAsync(final String nextPageLink, final ServiceCall serviceCall, final ListOperationCallback<CertificateIssuerItemInner> serviceCallback) throws IllegalArgumentException {
        if (serviceCallback == null) {
            throw new IllegalArgumentException("ServiceCallback is required for async calls.");
        }
        if (nextPageLink == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter nextPageLink is required and cannot be null."));
            return null;
        }
        this.restClient().setBaseUrl();
        Call<ResponseBody> call = service.getCertificateIssuersNext(nextPageLink, this.acceptLanguage(), this.userAgent());
        serviceCall.newCall(call);
        call.enqueue(new ServiceResponseCallback<List<CertificateIssuerItemInner>>(serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<PageImpl<CertificateIssuerItemInner>> result = getCertificateIssuersNextDelegate(response);
                    serviceCallback.load(result.getBody().getItems());
                    if (result.getBody().getNextPageLink() != null
                            && serviceCallback.progress(result.getBody().getItems()) == ListOperationCallback.PagingBahavior.CONTINUE) {
                        getCertificateIssuersNextAsync(result.getBody().getNextPageLink(), serviceCall, serviceCallback);
                    } else {
                        serviceCallback.success(new ServiceResponse<>(serviceCallback.get(), result.getResponse()));
                    }
                } catch (KeyVaultErrorException | IOException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<PageImpl<CertificateIssuerItemInner>> getCertificateIssuersNextDelegate(Response<ResponseBody> response) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<CertificateIssuerItemInner>, KeyVaultErrorException>(this.restClient().mapperAdapter())
                .register(200, new TypeToken<PageImpl<CertificateIssuerItemInner>>() { }.getType())
                .registerError(KeyVaultErrorException.class)
                .build(response);
    }

    /**
     * List the versions of a certificate.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws KeyVaultErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the List&lt;CertificateItemInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<PageImpl<CertificateItemInner>> getCertificateVersionsNext(final String nextPageLink) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        this.restClient().setBaseUrl();
        Call<ResponseBody> call = service.getCertificateVersionsNext(nextPageLink, this.acceptLanguage(), this.userAgent());
        return getCertificateVersionsNextDelegate(call.execute());
    }

    /**
     * List the versions of a certificate.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceCall the ServiceCall object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if callback is null
     * @return the {@link Call} object
     */
    public ServiceCall getCertificateVersionsNextAsync(final String nextPageLink, final ServiceCall serviceCall, final ListOperationCallback<CertificateItemInner> serviceCallback) throws IllegalArgumentException {
        if (serviceCallback == null) {
            throw new IllegalArgumentException("ServiceCallback is required for async calls.");
        }
        if (nextPageLink == null) {
            serviceCallback.failure(new IllegalArgumentException("Parameter nextPageLink is required and cannot be null."));
            return null;
        }
        this.restClient().setBaseUrl();
        Call<ResponseBody> call = service.getCertificateVersionsNext(nextPageLink, this.acceptLanguage(), this.userAgent());
        serviceCall.newCall(call);
        call.enqueue(new ServiceResponseCallback<List<CertificateItemInner>>(serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<PageImpl<CertificateItemInner>> result = getCertificateVersionsNextDelegate(response);
                    serviceCallback.load(result.getBody().getItems());
                    if (result.getBody().getNextPageLink() != null
                            && serviceCallback.progress(result.getBody().getItems()) == ListOperationCallback.PagingBahavior.CONTINUE) {
                        getCertificateVersionsNextAsync(result.getBody().getNextPageLink(), serviceCall, serviceCallback);
                    } else {
                        serviceCallback.success(new ServiceResponse<>(serviceCallback.get(), result.getResponse()));
                    }
                } catch (KeyVaultErrorException | IOException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<PageImpl<CertificateItemInner>> getCertificateVersionsNextDelegate(Response<ResponseBody> response) throws KeyVaultErrorException, IOException, IllegalArgumentException {
        return new AzureServiceResponseBuilder<PageImpl<CertificateItemInner>, KeyVaultErrorException>(this.restClient().mapperAdapter())
                .register(200, new TypeToken<PageImpl<CertificateItemInner>>() { }.getType())
                .registerError(KeyVaultErrorException.class)
                .build(response);
    }

}
